[
    {
        "id": "9e09f063-3b14-4342-a372-76a1ca033e45",
        "title": "",
        "chunk_text": "arXiv:2503.19188v1 [cs.CC] 24 Mar 2025 Upper and Lower Bounds for the Linear Ordering Principle Edward A. Hirsch∗ Ilya Volkovich† March 26, 2025 Abstract Korten and Pitassi (FOCS, 2024) deﬁned a new1 complexity class LP 2 as the polynomial- time Turing closure of the Linear Ordering Principle. They asked whether a Karp–Lipton– style collapse can be proven for LP 2. We answer this question aﬃrmatively by showing that PprMA ⊆LP 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "Linear",
                "Ordering",
                "Principle",
                "Mar",
                "March",
                "FOCS",
                "Upper",
                "Hirsch",
                "Ilya",
                "Volkovich"
            ]
        }
    },
    {
        "id": "b936508f-5d6a-40e9-87e1-b39c3b0b8889",
        "title": "",
        "chunk_text": "As a byproduct, we also answer an open question of Chakaravarthy and Roy (Computational Complexity, 2011) whether PprMA ⊆SP 2. We complement this result by providing a new upper bound for LP 2, namely LP 2 ⊆PprSBP. Thus we are placing LP 2 between PprMA and PprSBP. One technical ingredient of this result is an algorithm that approximates the number of satisfying assignments of a Boolean circuit using a prSBP oracle (i.e. in FPprSBP), which could be of independent interest.",
        "metadata": {
            "author": "",
            "keywords": [
                "Roy",
                "Computational",
                "Complexity",
                "Chakaravarthy",
                "byproduct",
                "PprSBP",
                "answer",
                "open",
                "question",
                "PprMA"
            ]
        }
    },
    {
        "id": "07317034-9e75-4e7e-80be-99b1fdec1aed",
        "title": "",
        "chunk_text": "Finally, we prove that PprOP 2 ⊆OP 2, which implies that the Karp–Lipton–style collapse to PprOMA is actually better than both known collapses to PprMA due to Chakaravarthy and Roy (Computational Complexity, 2011) and to OP 2 also due to Chakaravarthy and Roy (STACS, 2006). 1 Introduction The seminal theorem of Richard M. Karp and Richard J.",
        "metadata": {
            "author": "",
            "keywords": [
                "Roy",
                "Chakaravarthy",
                "Lipton",
                "STACS",
                "Computational",
                "Complexity",
                "due",
                "Karp",
                "Finally",
                "Richard"
            ]
        }
    },
    {
        "id": "5e969cf4-4aea-4f66-9a0c-e57a2c48ecda",
        "title": "",
        "chunk_text": "Lipton [KL80] connected non-uniform and uniform complexity by demonstrating a collapse of the Polynomial Hierarchy assuming NP has polynomial-size Boolean circuits. This collapse has since been very instrumental in transferring lower bounds against Boolean circuits of ﬁxed-polynomial2 size to smaller classes of the Polynomial Hierarchy. Since then, these results were strengthened in many ways yielding “minimal” classes that have such lower bounds and to which the Polynomial Hierarchy collapses.",
        "metadata": {
            "author": "",
            "keywords": [
                "Polynomial",
                "Hierarchy",
                "Boolean",
                "Lipton",
                "connected",
                "circuits",
                "non-uniform",
                "uniform",
                "complexity",
                "demonstrating"
            ]
        }
    },
    {
        "id": "07ef1b98-99a9-4431-a7c8-3a4ab0e23721",
        "title": "",
        "chunk_text": "1.1 Background 1.1.1 Classes Based on Symmetric Alternation An important notion in this context is that of symmetric alternation. Namely, one of the best col- lapses was based on the following idea ([Cai07], attributed to Sengupta): if polynomial-size circuits ∗Department of Computer Science, Ariel University, Israel. This research was conducted with the support of the State of Israel, the Ministry of Immigrant Absorption, and the Center for the Absorption of Scientists.",
        "metadata": {
            "author": "",
            "keywords": [
                "Symmetric",
                "Alternation",
                "Background",
                "Classes",
                "Based",
                "Israel",
                "Absorption",
                "important",
                "notion",
                "context"
            ]
        }
    },
    {
        "id": "84d7d5ab-08ec-440c-a45b-a87410e16a7d",
        "title": "",
        "chunk_text": "Email: edwardh@ariel.ac.il †Computer Science Department, Boston College, Chestnut Hill, MA. Email: ilya.volkovich@bc.edu 1Note that this notation had been used in the past [Sch83] for a very diﬀerent class, which has been apparently forgotten after that. 2That is, for any k ∈N, the class contains a language that cannot be computed by Boolean circuits of size nk, i.e. a language outside of Size[nk].",
        "metadata": {
            "author": "",
            "keywords": [
                "Email",
                "Computer",
                "Department",
                "Boston",
                "College",
                "Chestnut",
                "Hill",
                "Science",
                "size",
                "class"
            ]
        }
    },
    {
        "id": "4144f921-549f-452e-a77e-2142fc078e41",
        "title": "",
        "chunk_text": "1 for SAT exist, two provers (defending the answers ‘yes’ and ‘no’, respectively) send such circuits to a polynomial-time bounded veriﬁer who can use them to verify membership in any language in PH. The corresponding class SP 2 [Can96, RS98] was thus shown to have ﬁxed-polynomial circuit lower bounds. Indeed, since NP ⊆SP 2, if SAT requires super-polynomial circuits, we are done.",
        "metadata": {
            "author": "",
            "keywords": [
                "no’",
                "SAT",
                "exist",
                "provers",
                "defending",
                "answers",
                "yes’",
                "send",
                "polynomial-time",
                "bounded"
            ]
        }
    },
    {
        "id": "6e9892ff-450b-46ce-b3a3-31970337ed58",
        "title": "",
        "chunk_text": "Otherwise, the Polynomial Hierarchy, which is known to contain “hard” languages3 by Kannan’s theorem [Kan82], collapses to SP 2 and so do these hard languages. This technique has been known as a win-win argument in the literature [Kan82, BCG+96, KW98, Vin05, Cai07, San09, CR11, Vol14, IKV23]. Upon further inspection, one can observe that the presumed polynomial-size circuits for SAT do not actually depend on the input itself, but rather on its length.",
        "metadata": {
            "author": "",
            "keywords": [
                "Hierarchy",
                "Polynomial",
                "Kannan",
                "hard",
                "theorem",
                "collapses",
                "languages",
                "BCG",
                "SAT",
                "literature"
            ]
        }
    },
    {
        "id": "d28609e1-d56e-4205-9e21-fc450749df64",
        "title": "",
        "chunk_text": "Based on this observation, the collapse was deepened to the input-oblivious version of SP 2, called OP 2 [CR06]. Yet, since OP 2 is not known and, in fact, not believed to contain NP, the ﬁxed-polynomial lower bounds do not (immediately) carry over to OP 2. This state of aﬀairs remained unchanged for about ﬁfteen years until a signiﬁcant progress was made when Kleinberg et al. [KKMP21] initiated the study of total functions beyond TFNP.",
        "metadata": {
            "author": "",
            "keywords": [
                "Based",
                "observation",
                "called",
                "collapse",
                "deepened",
                "input-oblivious",
                "version",
                "immediately",
                "TFNP",
                "Kleinberg"
            ]
        }
    },
    {
        "id": "07e1bd66-c703-49ba-8834-9aa723e881ac",
        "title": "",
        "chunk_text": "That is, while Karp–Lipton’s theorem has not been improved, lower bounds against Size[nk] were pushed down to OP 2 [GLV24] and LP 2 [KP24], a new1 important class which we describe in more detail below. An important feature of these new results was that they were based on reducing ﬁnding a hard function to a total search problem. Namely, the works of Korten [Kor21] and Li [Li24] reduced the question to the so-called Range Avoidance problem.",
        "metadata": {
            "author": "",
            "keywords": [
                "Karp",
                "Lipton",
                "Size",
                "improved",
                "lower",
                "problem",
                "important",
                "theorem",
                "bounds",
                "pushed"
            ]
        }
    },
    {
        "id": "77f48f19-2e87-47b5-a205-e971f06737f2",
        "title": "",
        "chunk_text": "That is, given a function f : {0, 1}n →{0, 1}m with m > n, represented by a Boolean circuit, ﬁnd a point outside its image. In [CHR24, Li24], the range avoidance problem has been reduced to symmetric alternation. Subsequently, Korten and Pitassi [KP24] reduced the range avoidance problem to the Linear Ordering Principle: given an implicitly described ordering relation, either ﬁnd the smallest element or report a breach of the linear order axioms.",
        "metadata": {
            "author": "",
            "keywords": [
                "Boolean",
                "represented",
                "circuit",
                "image",
                "range",
                "avoidance",
                "function",
                "point",
                "Linear",
                "problem"
            ]
        }
    },
    {
        "id": "5619bac6-7145-4c4e-9f63-9e52fc20a27c",
        "title": "",
        "chunk_text": "A polynomial-time Turing closure of this principle gave rise to a new class LP 2 ⊆SP 2: a version of SP 2 where the two provers provide points of a polynomial-time veriﬁable linear order on binary strings of a certain length (each point starting with the corresponding answer 0 or 1), and the prover that provides the smaller element wins.",
        "metadata": {
            "author": "",
            "keywords": [
                "polynomial-time",
                "Turing",
                "length",
                "answer",
                "wins",
                "closure",
                "principle",
                "gave",
                "rise",
                "class"
            ]
        }
    },
    {
        "id": "6fd6a7c5-9555-4f21-b412-db45743f2cd7",
        "title": "",
        "chunk_text": "1.1.2 Classes Based on Merlin-Arthur Protocols In a parallel line of research, the same questions were considered for classes based on Merlin– Arthur proofs: Santhanam [San09] has shown ﬁxed-polynomial lower bounds for promise problems possessing such proofs (i.e. the class prMA). In [CR11], Chakaravarthy and Roy have shown a Karp–Lipton–style collapse and thus ﬁxed-polynomial size lower bounds for the class PprMA.",
        "metadata": {
            "author": "",
            "keywords": [
                "Santhanam",
                "Based",
                "Classes",
                "Merlin",
                "Arthur",
                "proofs",
                "Protocols",
                "bounds",
                "research",
                "prMA"
            ]
        }
    },
    {
        "id": "37a6612c-7bef-4b4a-8dac-79645863d58e",
        "title": "",
        "chunk_text": "In particular, they presented a new upper bound for SP 2 by showing that SP 2 ⊆PprAM. Combining this with a result of [AKSS95], that NP ⊆P/poly implies an “internal collapse” MA = AM4, they concluded that the Polynomial Hierarchy collapses all the way to PprMA. Subsequently, by applying the win-win argument, they obtained ﬁxed-polynomial bounds for PprMA, which (unlike prMA) is a class of languages.",
        "metadata": {
            "author": "",
            "keywords": [
                "PprAM",
                "PprMA",
                "presented",
                "upper",
                "showing",
                "Polynomial",
                "Hierarchy",
                "Subsequently",
                "Combining",
                "poly"
            ]
        }
    },
    {
        "id": "5c4ad3ad-a483-44f9-8d11-23a13f4669af",
        "title": "",
        "chunk_text": "It is to be noted though that since prMA is not a class of languages — while PprMA is, there is no immediate way to carry any lower bound against prMA over to PprMA. Nonetheless, the relationship between PprMA and the classes of symmetric alternation (including LP 2, OP 2, and SP 2) remained unknown. 3For every k ∈N : PH ̸⊆Size[nk]. 4The internal collapse goes through for the promise versions of the classes as well.",
        "metadata": {
            "author": "",
            "keywords": [
                "prMA",
                "PprMA",
                "languages",
                "noted",
                "class",
                "carry",
                "lower",
                "bound",
                "Size",
                "classes"
            ]
        }
    },
    {
        "id": "e101722c-4a4a-4f53-8f3f-93b1362a30f3",
        "title": "",
        "chunk_text": "2 1.1.3 SBP, Approximate Counting, and Set Size Estimation There is a class that sits between the two basic classes based on Arthur–Merlin protocols, yet its deﬁnition is not based on these protocols. The class SBP, which stands for small bounded-error polynomial-time computations, was introduced in [BGM06] by B¨ohler et al. as a relaxation of the class BPP to the case when the acceptance probability is not required to be bounded away from 0.",
        "metadata": {
            "author": "",
            "keywords": [
                "protocols",
                "SBP",
                "Approximate",
                "Counting",
                "Arthur",
                "Merlin",
                "based",
                "Set",
                "Size",
                "Estimation"
            ]
        }
    },
    {
        "id": "f8032292-1ad3-4a1e-b7c7-fa4193ebc9de",
        "title": "",
        "chunk_text": "Indeed, this relaxation gives more power and as a result, as was shown in [BGM06], MA ⊆SBP ⊆AM. Furthermore, SBP is the only known natural class that lies between MA and AM. Computing the number of accepting paths of a given non-deterministic Turing machine is a fundamental problem captured by the “counting” class #P. Yet, this class appears to be too powerful since, by Toda’s Theorem [Tod91], even a single query to it suﬃces to decide any language in the polynomial hierarchy, PH ⊆P#P[1]!",
        "metadata": {
            "author": "",
            "keywords": [
                "SBP",
                "result",
                "class",
                "relaxation",
                "power",
                "shown",
                "Theorem",
                "Turing",
                "counting",
                "Toda"
            ]
        }
    },
    {
        "id": "84f9134c-ecb8-48c5-af6b-33bda80e79e9",
        "title": "",
        "chunk_text": "Given that, it is natural to explore approximations. To this end, one can consider the problem of Approximate Counting which refers to the task of approximating the number of accepting paths (within a constant factor). Equivalently, this problem can be framed as approximating the size of a set S represented as the set of satisfying assignments of a Boolean circuit C.",
        "metadata": {
            "author": "",
            "keywords": [
                "approximations",
                "natural",
                "explore",
                "approximating",
                "problem",
                "Approximate",
                "Counting",
                "set",
                "Boolean",
                "end"
            ]
        }
    },
    {
        "id": "a4a73d9a-6b4d-4fa5-8d34-9ee782361cb6",
        "title": "",
        "chunk_text": "Previously, it was shown that this task could be carried out by a randomized algorithm using an NP oracle (FBPPNP) [Sto85, JVV86] and by a deterministic algorithm using a prAM oracle (FPprAM) [Sip83, GS86]. Shaltiel and Umans [SU06] show how to accomplish this task in FPNP, yet under a derandomization assumption. All of these algorithms can be implemented using parallel oracle queries. The decision version of the problem is to choose between two constant-factor estimates of the set size.",
        "metadata": {
            "author": "",
            "keywords": [
                "FBPPNP",
                "Previously",
                "FPprAM",
                "task",
                "oracle",
                "Umans",
                "FPNP",
                "shown",
                "carried",
                "randomized"
            ]
        }
    },
    {
        "id": "651f5e33-c59e-4032-af8c-b781acd15325",
        "title": "",
        "chunk_text": "For concreteness, consider the following problem called set-size estimation (or SSE for short): Given a set S (via a Boolean circuit C) and an integer m with a promise that either |S| ≥m or |S| ≤m/2, our goal is to decide which case holds. Interestingly, a result of [BGM06] implies that this problem is complete for the corresponding class prSBP of promise problems (and thus it is hard for SBP)!",
        "metadata": {
            "author": "",
            "keywords": [
                "SSE",
                "Boolean",
                "concreteness",
                "estimation",
                "short",
                "holds",
                "promise",
                "called",
                "set-size",
                "set"
            ]
        }
    },
    {
        "id": "432031ef-aea8-43f4-8dbc-b81ad2a58cb5",
        "title": "",
        "chunk_text": "In terms of upper bounds, in a seminal paper [GS86], Goldwasser and Sipser have exhibited an Arthur–Merlin protocol not only for this problem, but also for the case when the set S is represented by a non-deterministic circuit5! This more general version of the problem (WSSE, where the set S is given via a non-deterministic circuit), is complete for the class prAM.",
        "metadata": {
            "author": "",
            "keywords": [
                "Goldwasser",
                "Arthur",
                "Merlin",
                "Sipser",
                "problem",
                "set",
                "non-deterministic",
                "bounds",
                "paper",
                "WSSE"
            ]
        }
    },
    {
        "id": "99d8d838-d7cc-4e27-8d3a-a28c1c24e49e",
        "title": "",
        "chunk_text": "(See Deﬁnition 5.2 for the formal deﬁnition of the problems; in fact, the factor-of-two gap in the estimates is arbitrary and can be replaced by any positive constant. .) In fact, Goldwasser–Sipser’s protocol proves the containment both for languages (SBP ⊆AM) and for promise problems (prSBP ⊆prAM). At the same time, it is important to highlight the distinction between the two versions of the problem — i.e.",
        "metadata": {
            "author": "",
            "keywords": [
                "Deﬁnition",
                "fact",
                "problems",
                "gap",
                "constant.",
                "formal",
                "estimates",
                "arbitrary",
                "replaced",
                "positive"
            ]
        }
    },
    {
        "id": "755fdb20-d9a0-492f-a864-2babb3f390b6",
        "title": "",
        "chunk_text": "for the “standard” (SSE) vs non-deterministic (WSSE) Boolean circuits — which appears to be (at the very least) non-trivial. Notably, the work of [BGM06] established an oracle separation between SBP and AM. 1.2 Promise Problems as Oracles An important note is due on the use of a promise problem as an oracle, because the literature contains several diﬀerent notions for this. The collapse result of Chakaravarthy and Roy that we use follows the loose oracle access mode adopted in [CR11].",
        "metadata": {
            "author": "",
            "keywords": [
                "SSE",
                "WSSE",
                "Boolean",
                "standard",
                "non-trivial",
                "oracle",
                "non-deterministic",
                "circuits",
                "Promise",
                "SBP"
            ]
        }
    },
    {
        "id": "511b2da2-62c8-479e-86c3-16f11cf8596e",
        "title": "",
        "chunk_text": "Namely, oracle queries outside of the promise set are allowed and no particular behaviour of the computational model deﬁning the promise class is expected on such queries. At the same time, the answer of the (base) machine using 5A non-deterministic circuit C(x, w) accepts x if there exists a witness w for which C(x, w) = 1.",
        "metadata": {
            "author": "",
            "keywords": [
                "promise",
                "queries",
                "oracle",
                "set",
                "allowed",
                "behaviour",
                "computational",
                "model",
                "deﬁning",
                "class"
            ]
        }
    },
    {
        "id": "32dfdc38-4e00-4ef9-aef4-32834bf9180e",
        "title": "",
        "chunk_text": "3 this oracle must be correct irrespective of the oracle’s answers to such queries and no assumption is made on the internal consistency of the answers outside of the promise set. For deterministic polynomial-time oracle machines this approach is equivalent to querying any language consistent with the promise problem, that is, a language that contains all the “yes” instances and does not contain the “no” instances of the promise problem.",
        "metadata": {
            "author": "",
            "keywords": [
                "promise",
                "answers",
                "oracle",
                "set",
                "problem",
                "instances",
                "correct",
                "irrespective",
                "queries",
                "assumption"
            ]
        }
    },
    {
        "id": "ce50bbdf-65bf-44cf-93ef-203ab462df72",
        "title": "",
        "chunk_text": "One can also extend it to the classes of promise problems: A class C of languages is consistent with a class D of promise problems if for every problem Π ∈D there is a language L ∈C consistent with Π. The equivalence between the approaches follows from the works of [GS88, BF99], where the latter approach has been adopted. Nonetheless, we include a formal proof of this equivalence in Appendix C for the sake of completeness.",
        "metadata": {
            "author": "",
            "keywords": [
                "promise",
                "class",
                "consistent",
                "problems",
                "problem",
                "languages",
                "language",
                "extend",
                "classes",
                "equivalence"
            ]
        }
    },
    {
        "id": "125595c1-cfac-4432-9036-240d6f57b3d8",
        "title": "",
        "chunk_text": "1.3 Our Contribution 1.3.1 A New Lower Bound for LP 2 and the Strongest Non–Input-Oblivious Karp– Lipton Collapse The containment PprMA ⊆LP 2 and its consequences. Two open questions regarding sym- metric alternation have been stated explicitly: • whether a Karp–Lipton–style theorem holds for LP 2 [KP24], • whether PprMA is contained in SP 2 [CR11]. In this paper we resolve both these questions aﬃrmatively by showing the following containment. (Recall that LP 2 ⊆SP 2.) Theorem 1. PprMA ⊆LP 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "Karp",
                "Lipton",
                "Contribution",
                "Lower",
                "Bound",
                "Strongest",
                "Collapse",
                "PprMA",
                "Input-Oblivious",
                "consequences"
            ]
        }
    },
    {
        "id": "10e97d71-870b-4fe4-8807-7d28b4938794",
        "title": "",
        "chunk_text": "Combining this theorem with a result of Chakaravarthy and Roy [CR11] that NP ⊆P/poly implies the collapse PH = PprMA, we obtain a Karp–Lipton–style collapse theorem for LP 2, thus solving an open question posed in [KP24]. Corollary 2. If NP ⊆P/poly, then PH = LP 2 = PprMA. Which Karp–Lipton–style collapse is stronger? Theorem 1 shows that PprMA is currently the smallest non–input-oblivious class for which a Karp–Lipton–style collapse is known.",
        "metadata": {
            "author": "",
            "keywords": [
                "Lipton",
                "Roy",
                "Karp",
                "Chakaravarthy",
                "style",
                "collapse",
                "poly",
                "PprMA",
                "theorem",
                "Combining"
            ]
        }
    },
    {
        "id": "8de6c02a-e5a9-4414-a537-5e663ce3a9e4",
        "title": "",
        "chunk_text": "On the other hand, such a collapse is known for OP 2 [CR06], which is input-oblivious. However, the exact relationship between OP 2 and PprMA remains unknown. We demonstrate how to unify these results by observing that the collapse can be extended to PprOMA ⊆PprMA, where prOMA is the input- oblivious version of prMA and therefore is contained in prMA. At the same time, we show that PprOMA is also contained in OP 2, thus making PprOMA smaller than both PprMA and OP 2!",
        "metadata": {
            "author": "",
            "keywords": [
                "hand",
                "input-oblivious",
                "PprMA",
                "PprOMA",
                "collapse",
                "contained",
                "prMA",
                "unknown",
                "exact",
                "relationship"
            ]
        }
    },
    {
        "id": "e79e5869-519d-444a-8bdb-3d3dbcfec672",
        "title": "",
        "chunk_text": "As an intermediate step we show that PprOP 2 ⊆OP 2. Theorem 3. PprOMA ⊆PprOP 2 ⊆OP 2. We note that the “non-promise” version of the latter inclusion, i.e. POP 2 ⊆OP 2, was already es- tablished in [CR06]. Yet, this result does not carry over to the promise case. A similar phenomenon occurs with the non–input-oblivious analogue of this question: while we know that PSP 2 ⊆SP 2 [CR06], it still remains open whether PprSP 2 ⊆SP 2. 4 1.3.2 A New Upper Bound for LP 2 Containment.",
        "metadata": {
            "author": "",
            "keywords": [
                "PprOP",
                "intermediate",
                "step",
                "show",
                "POP",
                "Theorem",
                "Containment",
                "PSP",
                "Upper",
                "Bound"
            ]
        }
    },
    {
        "id": "1ab7f8b7-7a94-4e4c-977d-f035d8706fb2",
        "title": "",
        "chunk_text": "Our second main result is a new upper bound on LP 2. In particular, we prove that LP 2 ⊆PprSBP. The best known upper bound prior to our result followed from [KP24, CR11]: LP 2 ⊆SP 2 ⊆PprAM. Theorem 4. LP 2 ⊆PprSBP. In summary, our two new inclusions yield the following picture: MA SBP AM PprMA LP 2 PprSBP SP 2 PprAM Theorem 1 Theorem 4 Implications for “hard” functions.",
        "metadata": {
            "author": "",
            "keywords": [
                "Theorem",
                "PprSBP",
                "upper",
                "bound",
                "result",
                "main",
                "PprAM",
                "Implications",
                "SBP",
                "prove"
            ]
        }
    },
    {
        "id": "d38ed3aa-7ea7-4563-9124-c23ebbe92544",
        "title": "",
        "chunk_text": "In [KP24], Korten and Pitassi have shown that LE 2 — the exponential version of LP 2 — contains a language of circuit complexity 2n/n. By translation, our upper bound scales as LE 2 ⊆EprSBP. As a corollary we obtain new circuit lower bounds for EprSBP. To the best of our knowledge, the strongest previously established bound for this class was a “half-exponential” bound that followed from the bound on MAEXP [BFT98, MVW99]. Corollary 5. EprSBP contains a language of circuit complexity 2n/n.",
        "metadata": {
            "author": "",
            "keywords": [
                "Korten",
                "Pitassi",
                "bound",
                "circuit",
                "EprSBP",
                "complexity",
                "language",
                "shown",
                "exponential",
                "version"
            ]
        }
    },
    {
        "id": "9d5d2657-87be-49ef-b1bb-e29fc384cfdb",
        "title": "",
        "chunk_text": "It is to be noted that Corollary 5 could be viewed as an unconditional version of a result of Aydinlio˜glu et al. [AGHK11] as it recovers and strengthens their conclusion. In particular, [AGHK11] have shown the following6: if PNP is consistent with prAM or even prSBP, then ENP contains a language of circuit complexity 2n/n. Indeed, given the premises we obtain that EprSBP ⊆EPNP = ENP from which the claim follows directly by Corollary 5.",
        "metadata": {
            "author": "",
            "keywords": [
                "Aydinlio",
                "Corollary",
                "glu",
                "ENP",
                "noted",
                "viewed",
                "unconditional",
                "version",
                "result",
                "EPNP"
            ]
        }
    },
    {
        "id": "a839e577-540d-4e3b-b603-9eca11222d8b",
        "title": "",
        "chunk_text": "1.4 Our Techniques 1.4.1 Range Avoidance In [KP24], Korten and Pitassi show that MA ⊆LP 2. The inclusion PprMA ⊆LP 2 essentially follows their argument with the additional observation that since LP 2 is a syntactic class, not only it contains MA (as was shown) but it is also consistent with prMA. Thus one can ﬁrst construct a pseudorandom generator using an LP 2 oracle [Kor21, KP24] and then leverage it to fully derandomize the prMA oracle not just in prNP, but actually in NP ⊆LP 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "Techniques",
                "Range",
                "Korten",
                "Avoidance",
                "Pitassi",
                "show",
                "prMA",
                "oracle",
                "PprMA",
                "essentially"
            ]
        }
    },
    {
        "id": "a7fc0602-cfb0-42eb-910e-ecd5e6d10efe",
        "title": "",
        "chunk_text": "Therefore, PprMA ⊆PLP 2 = LP 2. 1.4.2 Input-Oblivious Symmetric Alternation A Karp–Lipton–style collapse to PprOMA follows from [CR11] by combining several previously known techniques. However, is this collapse stronger than the known collapse to OP 2 [CR06]? The 6The corresponding claims in [AGHK11] were stated using slightly diﬀerent terminology.",
        "metadata": {
            "author": "",
            "keywords": [
                "PLP",
                "Lipton",
                "Karp",
                "PprMA",
                "Symmetric",
                "Alternation",
                "collapse",
                "Input-Oblivious",
                "style",
                "techniques"
            ]
        }
    },
    {
        "id": "179486bf-46ce-4f35-bc3d-f157f23382b4",
        "title": "",
        "chunk_text": "5 inclusion prOMA ⊆prOP 2 can be transferred from a somewhat similar statement that was proven in [CR06]; however, in order to prove PprOMA ⊆OP 2 we need also the inclusion PprOP 2 ⊆OP 2, which seems novel.",
        "metadata": {
            "author": "",
            "keywords": [
                "prOP",
                "inclusion",
                "prOMA",
                "PprOMA",
                "PprOP",
                "transferred",
                "similar",
                "statement",
                "proven",
                "order"
            ]
        }
    },
    {
        "id": "16097ea8-844d-4e83-a284-0069e5ae540a",
        "title": "",
        "chunk_text": "The main idea is that the two provers corresponding to the oracle give their input-oblivious witnesses prior to the whole computation, and the veriﬁcation algorithm performs a cross-check not only between the witnesses of diﬀerent provers but also between the witnesses of the same prover, which allows us to simulate all oracle queries to prOP 2 in a single OP 2 algorithm.",
        "metadata": {
            "author": "",
            "keywords": [
                "witnesses",
                "oracle",
                "algorithm",
                "provers",
                "computation",
                "prOP",
                "main",
                "idea",
                "give",
                "input-oblivious"
            ]
        }
    },
    {
        "id": "0ac6d6b9-cf4d-44d8-b291-e0a0e46f32c1",
        "title": "",
        "chunk_text": "Indeed, our approach is made possible by the input-oblivious nature of the computational model: while the oracle queries may be adaptive and not known in advance (due to potential queries outside of the promise set), the witnesses are universal for the whole computation and nothing else is required.",
        "metadata": {
            "author": "",
            "keywords": [
                "queries",
                "model",
                "advance",
                "due",
                "set",
                "required",
                "approach",
                "made",
                "input-oblivious",
                "nature"
            ]
        }
    },
    {
        "id": "f7f868b9-98e4-4d1e-befc-cb1b23463368",
        "title": "",
        "chunk_text": "1.4.3 Approximate Counting and the Order Rank Approximation The upper bound LP 2 ⊆PprSBP is obtained by developing a process that, given an arbitrary element in a linearly ordered set, rapidly converges to the set’s minimum. Approximate counting using a prSBP oracle. We show how to deterministically approxi- mate the number of satisfying assignments of a Boolean circuit, given oracle access to prSBP (i.e. in FPprSBP), using parallel queries.",
        "metadata": {
            "author": "",
            "keywords": [
                "Approximate",
                "Order",
                "Rank",
                "Approximation",
                "set",
                "Counting",
                "PprSBP",
                "rapidly",
                "minimum",
                "upper"
            ]
        }
    },
    {
        "id": "1d92bc05-d55b-40ab-9ac7-e32b1ab96301",
        "title": "",
        "chunk_text": "Our algorithm is based on SBP ampliﬁcation that was used in [BGM06, Vol20]. A crucial observation is that, as we need a multiplicative approximation (up to the factor 1+ε), it suﬃces to place the desired number between two consecutive powers of two; the correct place then could be found by either querying a prSBP oracle O(n/ε) times in parallel or (using binary search) O(log2(n/ε)) times sequentially. This result could be on independent interest. See Lemma 5.6 for the formal statement.",
        "metadata": {
            "author": "",
            "keywords": [
                "SBP",
                "times",
                "algorithm",
                "based",
                "ampliﬁcation",
                "place",
                "Lemma",
                "approximation",
                "factor",
                "search"
            ]
        }
    },
    {
        "id": "db82e9db-b614-4258-b3dd-74068c8fc727",
        "title": "",
        "chunk_text": "Approximating the rank w.r.t. a linear order. The rank of an element α of a linearly ordered set U is the number of elements in this set that are strictly less than α (in particular, α is the minimum if and only if rank(α) = 0). We can extend this deﬁnition to non-empty subsets S ⊆U, where rank(S) is the average rank of elements in S. We reduce the problem of approximately comparing the average ranks of two sets to approximate counting.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "Approximating",
                "order",
                "elements",
                "linear",
                "average",
                "set",
                "ranks",
                "element",
                "linearly"
            ]
        }
    },
    {
        "id": "044de349-3a7d-4062-a63f-4f4541ff55c5",
        "title": "",
        "chunk_text": "To see how, consider a strict linear order <E implicitly deﬁned on U = {0, 1}n using a Boolean circuit E, and observe that for a non-empty subset S ⊆U, the average rank of S is exactly the size of the set of pairs {(υ, α) ∈U × S | υ <E α} divided by the size of S. Hence, this task can be carried out using a prSBP oracle. An upper bound for the Linear Ordering Principle.",
        "metadata": {
            "author": "",
            "keywords": [
                "size",
                "Boolean",
                "order",
                "pairs",
                "divided",
                "linear",
                "strict",
                "implicitly",
                "deﬁned",
                "circuit"
            ]
        }
    },
    {
        "id": "632c6eaf-19b9-43a6-b70b-0f405a49323b",
        "title": "",
        "chunk_text": "As was mentioned, we develop a process that, given an arbitrary element in a linearly ordered set U = {0, 1}n, rapidly converges to the set’s minimum. Given an element α ∈U, we ﬁrst deﬁne the set S as the set of all the elements less or equal to α. Formally, S := {x | x ≤α}. Observe that rank(S) = rank(α)/2. We then iteratively partition S into two disjoint sets, starting from i = 1: S0 = {x ∈S | xi = 0} and S1 = {x ∈S | xi = 1}. By averaging argument, min {rank(S0), rank(S1)} ≤rank(S).",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "set",
                "element",
                "mentioned",
                "rapidly",
                "minimum",
                "develop",
                "process",
                "arbitrary",
                "linearly"
            ]
        }
    },
    {
        "id": "27171e8e-5979-4ca3-8edd-1a4d7fdc88d6",
        "title": "",
        "chunk_text": "We then take S to be the subset (S0 or S1) with the smaller rank and continue to the next value of i. That is, we ﬁx the bits of the 6 elements of S one coordinate at a time. Therefore, once i = n, our “ﬁnal” set S contains exactly one element β and thus at that point rank(S) = rank(β). On the other hand, as the rank of the “initial” S was rank(α)/2 and the overall rank could only decrease, we obtain that rank(β) ≤rank(α)/2. We can then invoke the same procedure this time with β as its input.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "subset",
                "smaller",
                "continue",
                "time",
                "elements",
                "element",
                "bits",
                "coordinate",
                "ﬁnal"
            ]
        }
    },
    {
        "id": "e123fb75-4c50-4d66-b08b-3149a311d345",
        "title": "",
        "chunk_text": "As the there are 2n elements in U, this process will converge to the set’s minimum after invoking the procedure at most n times, given any initial element. The algorithm described above requires computing (or at least comparing) the average ranks of two sets. Our analysis demonstrates that a procedure for approximate comparison, developed before, is suﬃcient for the implementation of this idea (though the factor at each step will be a little bit less than 2).",
        "metadata": {
            "author": "",
            "keywords": [
                "times",
                "elements",
                "element",
                "process",
                "converge",
                "minimum",
                "invoking",
                "initial",
                "procedure",
                "set"
            ]
        }
    },
    {
        "id": "0c79454e-29c4-4403-8663-ad5eac177d1e",
        "title": "",
        "chunk_text": "1.5 Organization of the Paper In Section 2 we give the necessary deﬁnitions. Section 3 contains the proof of Theorem 1 answering the open questions of Korten and Pitassi [KP24] and Chakaravarthy and Roy [CR11]. Section 4 contains the proof of Theorem 3 which implies that collapse to PprOMA is better than both collapses to PprMA and to OP 2. Section 5 contains the proof of Theorem 4. In Section 6 we outline further directions for the research.",
        "metadata": {
            "author": "",
            "keywords": [
                "Section",
                "Theorem",
                "Organization",
                "Paper",
                "proof",
                "deﬁnitions",
                "Pitassi",
                "Roy",
                "give",
                "Korten"
            ]
        }
    },
    {
        "id": "5f85635c-9ce6-4982-ac0b-a0e30646284f",
        "title": "",
        "chunk_text": "In Appendix C we discuss oracle access modes in a formalistic way. The two other Appendices A and B contain formal proofs of statements (used in Section 4) that essentially follow from the proofs of [AKSS95, CR06, CR11] (namely, the collapse to PprOMA and the inclusion prOMA ⊆prOP 2), we provide these proofs for the sake of completeness. 2 Deﬁnitions 2.1 Promise Classes as Oracles A promise problem is a relaxation of (the decision problem for) a language. Deﬁnition 2.1 (promise problem).",
        "metadata": {
            "author": "",
            "keywords": [
                "Appendix",
                "proofs",
                "Promise",
                "problem",
                "discuss",
                "access",
                "modes",
                "formalistic",
                "Section",
                "Deﬁnitions"
            ]
        }
    },
    {
        "id": "7ecd65d1-0234-46ac-95b5-c7f97c3d80e4",
        "title": "",
        "chunk_text": "Π = (ΠYES, ΠNO) is a promise problem if ΠYES ∩ΠNO = ∅. We say that a language O is consistent with Π, if ΠYES ⊆O and ΠNO ⊆O. Similarly to [CR11], when an oracle is described as a promise problem, we use loose access to the oracle. The outer Turing machine is allowed to make queries outside of the promise set, and the oracle does not need to conform to the deﬁnition of the promise oracle class for such queries.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "promise",
                "oracle",
                "problem",
                "queries",
                "Turing",
                "language",
                "consistent",
                "Similarly"
            ]
        }
    },
    {
        "id": "869858a2-5570-4f9a-9584-91ba9a2ad0d1",
        "title": "",
        "chunk_text": "However, the outer Turing machine must return the correct answer irrespective of oracle’s behavior for queries outside of the promise set in particular, the oracle does not need to be consistent in its answers to the same query. Refer to Appendix C for formalistic deﬁnitions and further discussion. 2.2 Problems Avoid and LOP Deﬁnition 2.2 (Avoid, Range Avoidance, [KKMP21, Kor21]). Avoid is the following total search problem. Input: circuit C with n inputs and m > n outputs.",
        "metadata": {
            "author": "",
            "keywords": [
                "Turing",
                "oracle",
                "Avoid",
                "query",
                "answer",
                "answers",
                "outer",
                "machine",
                "return",
                "correct"
            ]
        }
    },
    {
        "id": "f1da14ea-5c73-493c-b95f-db9268acc7d7",
        "title": "",
        "chunk_text": "Output: y ∈{0, 1}m \\ Im C. Korten [Kor21] proved that for a stretch of n + 1 this problem is equivalent to a stretch of O(n) (and, of course, vice versa) using PNP reductions. 7 The following deﬁnition is due to Korten and Pitassi [KP24]: Deﬁnition 2.3 (LOP, Linear Ordering Principle). LOP is the following total search problem. Input: ordering relation <E given as a Boolean circuit E with 2n inputs.",
        "metadata": {
            "author": "",
            "keywords": [
                "stretch",
                "PNP",
                "Output",
                "Korten",
                "LOP",
                "proved",
                "vice",
                "versa",
                "reductions",
                "deﬁnition"
            ]
        }
    },
    {
        "id": "335297b0-5beb-42ec-a9f2-4bf6767781b6",
        "title": "",
        "chunk_text": "Output: either the minimum for <E (that is, x such that ∀y ∈{0, 1}n \\ {x} x <E y) or a counterex- ample, if <E is not a strict linear order. A counterexample is either a pair satisfying x <E y <E x or a triple satisfying x <E y <E z <E x. 2.3 Complexity Classes The following two deﬁnitions have been suggested by Korten and Pitassi who also proved their equivalence [KP24]. Deﬁnition 2.4 (LP 2 via reductions). A language L ∈LP 2 if it can be reduced to LOP using a PNP- Turing reduction.",
        "metadata": {
            "author": "",
            "keywords": [
                "Output",
                "ample",
                "counterex",
                "order",
                "satisfying",
                "minimum",
                "strict",
                "linear",
                "Complexity",
                "Classes"
            ]
        }
    },
    {
        "id": "04d3a8d9-82cf-474b-8982-17b888f69651",
        "title": "",
        "chunk_text": "(Polynomial-time Turing reductions and polynomial-time many-one reductions have the same eﬀect, as proved in [KP24].) The following is an alternative deﬁnition of LP 2, which was shown in [KP24] to be equivalent. Deﬁnition 2.5 (LP 2 via symmetric alternation).",
        "metadata": {
            "author": "",
            "keywords": [
                "Polynomial-time",
                "Turing",
                "reductions",
                "eﬀect",
                "many-one",
                "proved",
                "deﬁnition",
                "equivalent",
                "alternation",
                "alternative"
            ]
        }
    },
    {
        "id": "e1bd756f-3f52-4229-8341-c4227405018d",
        "title": "",
        "chunk_text": "A language L ∈LP 2 if there is a ternary relation R computable in time s(n), where s is a polynomial, R ⊆{0, 1}n × {0, 1}s(n) × {0, 1}s(n), denoted Rx(u, v) for x ∈{0, 1}n, u, v ∈{0, 1}s(n), such that, for every ﬁxed x, it deﬁnes a linear order on s(|x|)-size strings such that: • for every x ∈L, the minimal element of this order starts with bit 1, • for every x /∈L, the minimal element of this order starts with bit 0.",
        "metadata": {
            "author": "",
            "keywords": [
                "bit",
                "order",
                "minimal",
                "element",
                "starts",
                "polynomial",
                "denoted",
                "size",
                "language",
                "ternary"
            ]
        }
    },
    {
        "id": "9662ca2a-14c9-4314-a540-10d29b6d4e21",
        "title": "",
        "chunk_text": "It is obvious that the latter version of the deﬁnition is a particular case of the deﬁnition of SP 2 [Can96, RS98]: Deﬁnition 2.6. A language L ∈SP 2 if there is a polynomial-time computable ternary relation R ⊆{0, 1}n × {0, 1}s(n) × {0, 1}s(n), denoted Rx(u, v) for x ∈{0, 1}n, u, v ∈{0, 1}s(n), such that: • for every x ∈L, there exists w(1) such that ∀v Rx(w(1), v) = 1, • for every x /∈L, there exists w(0) such that ∀u Rx(u, w(0)) = 0.",
        "metadata": {
            "author": "",
            "keywords": [
                "deﬁnition",
                "exists",
                "obvious",
                "version",
                "case",
                "denoted",
                "language",
                "polynomial-time",
                "computable",
                "ternary"
            ]
        }
    },
    {
        "id": "6070fa95-4d41-4838-87ce-0dfba4afb10e",
        "title": "",
        "chunk_text": "We now formally deﬁne the class OP 2 [CR06], which is the input-oblivious version of SP 2. Since we will need also a promise version of it, we start with deﬁning this generalization. Deﬁnition 2.7.",
        "metadata": {
            "author": "",
            "keywords": [
                "version",
                "formally",
                "deﬁne",
                "class",
                "input-oblivious",
                "Deﬁnition",
                "generalization",
                "promise",
                "start",
                "deﬁning"
            ]
        }
    },
    {
        "id": "37f43b89-0fa1-4f61-b8e3-91902c3007d1",
        "title": "",
        "chunk_text": "A promise problem Π = (ΠYES, ΠNO) belongs to prOP 2 if there is a polynomial-time deterministic Turing machine A such that for every n ∈N, there exist w(0) n , w(1) n (called irrefutable certiﬁcates) that satisfy: • If x ∈ΠYES, then for every v, A(x, w(1) n , v) = 1, • If x ∈ΠNO, then for every u, A(x, u, w(0) n ) = 0. No assumption on the behaviour of A is made outside the promise set except that it stops (accepts or rejects) in polynomial time.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "Turing",
                "belongs",
                "prOP",
                "called",
                "certiﬁcates",
                "satisfy",
                "promise",
                "problem"
            ]
        }
    },
    {
        "id": "c7e754ae-87cc-450b-b48c-dc3545ffbab7",
        "title": "",
        "chunk_text": "OP 2 is the respective class of languages (that is, it corresponds to the case of ΠYES = ΠNO). 8 3 PprMA ⊆LP 2 In this section we prove Theorem 1 by, essentially, expanding the proof of MA ⊆LP 2 in [KP24]. We use the following statements from that paper and an earlier paper by Korten [Kor21]. Deﬁnition 3.1 ([Kor21, Deﬁnitions 7, 8]). PRG is the following search problem: given 1n, output a pseudorandom generator7 R = (x1, . . .",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠNO",
                "ΠYES",
                "languages",
                "respective",
                "class",
                "corresponds",
                "case",
                "Theorem",
                "Deﬁnition",
                "Deﬁnitions"
            ]
        }
    },
    {
        "id": "a8eef6a5-667f-432a-816a-675ec866c9a6",
        "title": "",
        "chunk_text": ", xm), that is, an array of strings xi ∈{0, 1}n such that for every n-input circuit C of size n: Pr x←U(R){C(x) = 1} − Pr y←U({0,1}n){C(y) = 1} ≤1 n. Korten demonstrates that such a generator containing m = n6 strings can be constructed with a single oracle query to Avoid8 (actually, the stretch is even larger than “plus 1 output wire”). Proposition 3.2 ([Kor21, Theorem 3]). PRG reduces in polynomial time to Avoid.",
        "metadata": {
            "author": "",
            "keywords": [
                "strings",
                "array",
                "n-input",
                "circuit",
                "size",
                "Theorem",
                "PRG",
                "Avoid",
                "Korten",
                "output"
            ]
        }
    },
    {
        "id": "f9d22d8f-8ee1-4040-8de0-05bf896258cb",
        "title": "",
        "chunk_text": "Korten and Pitassi demonstrate that Avoid (which they call Weak Avoid) can be solved with one oracle query to LOP. Proposition 3.3 ([KP24, Theorem 1]). Avoid is polynomial-time many-one reducible to LOP. The main result of this section is the following theorem. Theorem 3.4 (Theorem 1, restated). PprMA ⊆LP 2. Proof. We show how to replace the oracle prMA by LP 2. Since PLP 2 = LP 2 by Deﬁnition 2.4, the result follows.",
        "metadata": {
            "author": "",
            "keywords": [
                "LOP",
                "Pitassi",
                "Weak",
                "Theorem",
                "Avoid",
                "Korten",
                "demonstrate",
                "call",
                "solved",
                "query"
            ]
        }
    },
    {
        "id": "929e636a-5474-4e8a-b2ec-44af664cb6cc",
        "title": "",
        "chunk_text": "One can assume that calls to the prMA oracle are made for input lengths such that Arthur can be replaced by a circuit A(x, w, r) of size at most s(n) for a speciﬁc polynomial s. One can assume perfect completeness for A, that is, for x in the promise set “YES”, there is w such that ∀r A(x, w, r) = 1.",
        "metadata": {
            "author": "",
            "keywords": [
                "Arthur",
                "assume",
                "calls",
                "prMA",
                "oracle",
                "made",
                "input",
                "lengths",
                "replaced",
                "circuit"
            ]
        }
    },
    {
        "id": "2181dc63-7cb1-43eb-ab5f-16c18e1433ba",
        "title": "",
        "chunk_text": "Before simulating the prMA oracle, our deterministic polynomial-time Turing machine will make oracle calls to LP 2 in order to build a pseudorandom generator suﬃcient to derandomize circuits of size s(n). By Proposition 3.2, such a pseudorandom generator G, which is a sequence G(1s(n)) of pseudorandom strings g1, . . . , gm ∈{0, 1}s(n) for m bounded by a polynomial in s(n), can constructed (for m = s(n)6 and error 1 s(n)) using a reduction to Avoid.",
        "metadata": {
            "author": "",
            "keywords": [
                "pseudorandom",
                "Turing",
                "oracle",
                "generator",
                "simulating",
                "prMA",
                "deterministic",
                "polynomial-time",
                "machine",
                "make"
            ]
        }
    },
    {
        "id": "e8c24677-919a-4641-8f1f-24b2124623f5",
        "title": "",
        "chunk_text": "Subsequently, by Proposition 3.3, Avoid is reducible to LOP. As a result, {gi}m i=1 can be computed in deterministic polynomial time by querying an LP 2 oracle. After G is computed, each call to the prMA oracle can be replaced by an NP ⊆LP 2 query ∃w C(w) for the circuit C that computes the conjunction of the circuits A(x, w, gi) with hardwired x and gi, for every i.",
        "metadata": {
            "author": "",
            "keywords": [
                "Proposition",
                "Avoid",
                "LOP",
                "Subsequently",
                "reducible",
                "computed",
                "oracle",
                "query",
                "result",
                "deterministic"
            ]
        }
    },
    {
        "id": "85177c90-ee74-4197-bac9-3c2f2372a4d3",
        "title": "",
        "chunk_text": "Note that such queries constructed for x outside of the promise set are still valid NP queries even if Arthur does not conform to the deﬁnition of MA in this case. These oracle answers are irrelevant, because the original PprMA machine must return the correct (in particular, the same) answer irrespectively of the oracle’s answer. 7Korten does not say that m has a polynomial dependence on n though we think it is assumed, and anyway his theorem provides a construction with m = n6.",
        "metadata": {
            "author": "",
            "keywords": [
                "Arthur",
                "queries",
                "Note",
                "case",
                "constructed",
                "promise",
                "set",
                "valid",
                "conform",
                "deﬁnition"
            ]
        }
    },
    {
        "id": "3a064c36-a42f-4ace-8f97-a75ad1223f67",
        "title": "",
        "chunk_text": "8In the paper the Avoid problem is refered to as “Empty”. 9 4 Which Karp–Lipton–style Collapse is Better? Chakaravarthy and Roy proved two Karp–Lipton–style collapses: down to OP 2 [CR06] and down to PprMA [CR11]. These two classes seem to be incomparable thereby rising the question: which collapse result is stronger?",
        "metadata": {
            "author": "",
            "keywords": [
                "Empty",
                "Lipton",
                "Avoid",
                "Karp",
                "style",
                "Collapse",
                "paper",
                "problem",
                "refered",
                "Roy"
            ]
        }
    },
    {
        "id": "96f66c43-383f-4dd6-8adc-906e58309dcb",
        "title": "",
        "chunk_text": "We observe that the collapse to PprMA can actually be deepened to PprOMA, where prOMA is the oblivious version of prMA — and subsequently show that latter class is contained in both previous classes. That is, PprOMA ⊆PprMA ∩OP 2. Indeed, the “internal collapse” of prMA (and, in fact, even prAM) to prOMA, under the assumption that NP ⊆P/poly, is implicit in [AKSS95]. Nonetheless, we include a formal proof in Appendix A in order to present a self-contained argument. Proposition 4.1 (Prop. A.1).",
        "metadata": {
            "author": "",
            "keywords": [
                "PprOMA",
                "prMA",
                "classes",
                "PprMA",
                "observe",
                "deepened",
                "oblivious",
                "version",
                "subsequently",
                "show"
            ]
        }
    },
    {
        "id": "b8dec418-ea1d-41ff-9288-a8d61f9b12c9",
        "title": "",
        "chunk_text": "If NP ⊆ P/poly, then prAM ⊆ prOMA and PH = PprOMA. To show that this class is not only included in PprMA but also in OP 2, we use two inclusions: 1. prOMA ⊆prOP 2, 2. PprOP 2 ⊆OP 2. The ﬁrst inclusion is essentially proved in [CR06, Theorem 3], which says that MA ⊆NOP 2 (⊆OP 2). One needs to notice that the proof goes through for promise classes. Proposition 4.2 (Prop. B.1). prOMA ⊆prOP 2. We include a formal proof of this proposition in Appendix B.",
        "metadata": {
            "author": "",
            "keywords": [
                "prOMA",
                "poly",
                "PprOMA",
                "prAM",
                "prOP",
                "Theorem",
                "NOP",
                "proof",
                "Proposition",
                "Prop."
            ]
        }
    },
    {
        "id": "8c153f35-f166-43f6-98e7-a5fdaa85e555",
        "title": "",
        "chunk_text": "The second inclusion seems novel and is proved in the following lemma: Lemma 4.3. PprOP 2 ⊆OP 2. Remark: Formally, we show that PΠ ⊆OP 2 for every promise problem Π ∈prOP 2. Proof. Let L ∈PΠ and let M• be a deterministic oracle machine that decides L correctly given loose oracle access to Π (i.e. irrespective of the answers to its queries outside of the promise set), in time p(n) (for a polynomial p). Consider the polynomial-time deterministic veriﬁer A(q, u, v) from the deﬁnition of Π ∈prOP 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "lemma",
                "prOP",
                "inclusion",
                "proved",
                "Formally",
                "promise",
                "deterministic",
                "oracle",
                "PprOP",
                "Remark"
            ]
        }
    },
    {
        "id": "1d0bf191-7c25-4833-886b-3ca925fca562",
        "title": "",
        "chunk_text": "For n ∈N, let 1, . . . , p(n) be all possible lengths of oracle queries made by M given an input of length n. Deﬁne Wn := (w(0) 1 , . . . , w(0) p(n), w(1) 1 , . . . , w(1) p(n)) as a vector containing the irrefutable certiﬁcates (both “yes” and “no”) of A for the appropriate input lengths.",
        "metadata": {
            "author": "",
            "keywords": [
                "input",
                "lengths",
                "Deﬁne",
                "oracle",
                "queries",
                "made",
                "length",
                "certiﬁcates",
                "vector",
                "irrefutable"
            ]
        }
    },
    {
        "id": "13264688-3625-40f9-a424-7b7c1be33008",
        "title": "",
        "chunk_text": "We now construct a new polynomial-time deterministic veriﬁer A′(x, U, V ) that will demonstrate that L ∈OP 2 and will show that, for any x, the string9 W|x| constitutes an irrefutable certiﬁcate that can be used both as U = (u(0) 1 , . . . , u(0) p(n), u(1) 1 , . . . , u(1) p(n)) and as V = (v(0) 1 , . . . , v(0) p(n), v(1) 1 , . . . , v(1) p(n)). 9There might be diﬀerent versions of this string as the irrefutable certiﬁcates need not to be unique.",
        "metadata": {
            "author": "",
            "keywords": [
                "constitutes",
                "construct",
                "polynomial-time",
                "deterministic",
                "veriﬁer",
                "demonstrate",
                "show",
                "irrefutable",
                "certiﬁcate",
                "unique"
            ]
        }
    },
    {
        "id": "d7c118ac-49af-4709-9e1d-b8b41bfac594",
        "title": "",
        "chunk_text": "10 Given (x, U, V ) as an input, A′ will simulate M. Whenever M makes an oracle query q to Π, A′ will compute four bits: a := A(q, u(1) |q| , v(0) |q| ), b := A(q, v(1) |q| , u(0) |q| ), c := A(q, u(1) |q| , u(0) |q| ), d := A(q, v(1) |q| , v(0) |q| ), and will proceed with the simulation of M as if the oracle answered ℓ:= (a ∧c) ∨(b ∧d). By deﬁnition, for any x, the machine M computes L(x) correctly given the correct answers to the queries in the promise set (i.e.",
        "metadata": {
            "author": "",
            "keywords": [
                "input",
                "simulate",
                "oracle",
                "compute",
                "computes",
                "bits",
                "makes",
                "query",
                "proceed",
                "simulation"
            ]
        }
    },
    {
        "id": "87d2905e-1401-4619-ae90-a80821dd4d9a",
        "title": "",
        "chunk_text": "q ∈ΠYES ∪ΠNO) and irrespective of the oracle’s answers outside of the promise set. Thus it suﬃces to prove that the oracle’s answers to the queries in the promise set are computed correctly, which we show now by inspecting the four possible cases. • Suppose x ∈L and U = W|x|. – If q ∈ΠYES then u(1) |q| is a ‘yes’-irrefutable certiﬁcate and hence a = c = 1 =⇒ℓ= 1. – If q ∈ΠNO then u(0) |q| is a ‘no’-irrefutable certiﬁcate and hence b = c = 0 =⇒ℓ= 0. • Suppose x ̸∈L and V = W|x|.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "oracle",
                "promise",
                "Suppose",
                "answers",
                "set",
                "irrespective",
                "certiﬁcate",
                "correctly"
            ]
        }
    },
    {
        "id": "bbd5df1c-a741-4e4f-9d2d-8c66906698ba",
        "title": "",
        "chunk_text": "– If q ∈ΠYES then v(1) |q| is a ‘yes’-irrefutable certiﬁcate and hence b = d = 1 =⇒ℓ= 1. – If q ∈ΠNO then v(0) |q| is a ‘no’-irrefutable certiﬁcate and hence a = d = 0 =⇒ℓ= 0. Theorem 4.4 (Theorem 3, restated). PprOMA ⊆OP 2. Proof. By Proposition 4.2 and Lemma 4.3. Remark 4.5. When a semantic class without complete problems is used as an oracle, it may be ambiguous. However, prAM does have a complete problem WSSE (see Deﬁnition 5.2). By inspecting the proof of the collapse (Prop.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "Theorem",
                "certiﬁcate",
                "yes’-irrefutable",
                "ΠNO",
                "complete",
                "Proof",
                "Prop",
                "Proposition",
                "Lemma"
            ]
        }
    },
    {
        "id": "9d0cebeb-f2ea-4dfb-bd04-af6c15175472",
        "title": "",
        "chunk_text": "4.1) one can observe that WSSE actually belongs to prOMA under NP ⊆P/poly, and the oracle Turing machine that demonstrates PH = PprOMA still queries a speciﬁc promise problem. For the inclusion of PprOMA in OP 2, the ﬁrst part (Prop. 4.2) transforms one promise problem into another promise problem, thus in the inclusion PprOMA ⊆PprOP 2 it is also the case that a single oracle is replaced by (another) single oracle. 5 LP 2 ⊆PprSBP In this section we prove Theorem 4.",
        "metadata": {
            "author": "",
            "keywords": [
                "WSSE",
                "Turing",
                "poly",
                "promise",
                "problem",
                "oracle",
                "PprOMA",
                "Prop",
                "observe",
                "belongs"
            ]
        }
    },
    {
        "id": "49e4f3c3-6a65-4afc-995e-33027b13096f",
        "title": "",
        "chunk_text": "Our proof strategy is as follows: Given a point in a linear order, we aim to move “down the order” (i.e. towards “smaller” points). At each stage we will skip over a constant fraction of the points remaining on our way to the minimum. In order to ﬁnd the next point, we will employ a binary-search-like procedure to determine the bits of the desired point, one coordinate at a time.",
        "metadata": {
            "author": "",
            "keywords": [
                "smaller",
                "order",
                "point",
                "move",
                "proof",
                "strategy",
                "linear",
                "aim",
                "points",
                "minimum"
            ]
        }
    },
    {
        "id": "054f538a-ab9c-4732-947c-5b577e5107cd",
        "title": "",
        "chunk_text": "Here is where our prSBP oracle comes into play: At each step, we look at the remaining set of points partitioned into two subsets: the points where the appropriate bit is 0 and where that bit is 1, and select the subset with the (approximately) smaller average rank. Before we proceed with the main algorithm, we show how to approximate the size of a set using a prSBP oracle. This procedure could be of independent interest.",
        "metadata": {
            "author": "",
            "keywords": [
                "bit",
                "points",
                "approximately",
                "prSBP",
                "oracle",
                "set",
                "play",
                "step",
                "smaller",
                "rank"
            ]
        }
    },
    {
        "id": "c1c3fccd-302c-4ea9-a7d1-ab82fcaed61f",
        "title": "",
        "chunk_text": "11 5.1 Approximate Counting For a unary relation R(x), we denote the number of elements in R as #xR(x) := |{x | x ∈R}|. We will also abbreviate this notation to #xR. For k ∈N, we deﬁne R⊗k — the k-th tensor power of R as R⊗k((x1, . . . , xk)) := R(x1) ∧R(x2) ∧. . . ∧R(xk), where x1, . . . , xk are k disjoint copies of the argument x of R, respectively. Observation 5.1. Then #x(R⊗k) = (#xR)k. Note that queries to prSBP can be thought of as queries to a speciﬁc promise problem.",
        "metadata": {
            "author": "",
            "keywords": [
                "Approximate",
                "Counting",
                "unary",
                "relation",
                "denote",
                "number",
                "elements",
                "queries",
                "abbreviate",
                "notation"
            ]
        }
    },
    {
        "id": "0f0f92da-cdcc-4f3d-ac9f-b14e2ce9c530",
        "title": "",
        "chunk_text": "Deﬁnition 5.2 (Set-Size Estimation, SSE and WSSE). Let C be a Boolean circuit and m ≥1 be an integer given in binary representation. Then SSE := (SSEYES, SSENO), where SSEYES = {(C, m) | #xC(x) ≥m}, SSENO = {(C, m) | #xC(x) ≤m/2}. If C is a non-deterministic circuit, we denote the corresponding problem by WSSE. These two promise problems are complete for promise classes prSBP and prAM, respectively. This is what is proved essentially in [BGM06] and [GS86] and formulated explicitly in [Vol20].",
        "metadata": {
            "author": "",
            "keywords": [
                "Estimation",
                "SSENO",
                "WSSE",
                "Deﬁnition",
                "SSE",
                "SSEYES",
                "Set-Size",
                "Boolean",
                "circuit",
                "promise"
            ]
        }
    },
    {
        "id": "3f57c05b-fb74-45c0-b977-1dc0e267e6bf",
        "title": "",
        "chunk_text": "Lemma 5.3 (Implicit in [BGM06]). SSE is prSBP-complete. Lemma 5.4 (Implicit in [GS86]). WSSE is prAM-complete. In particular, these complete problems showcase that prSBP ⊆prAM. Observation 5.5 (Useful inequalities). Let x, y ≥0 and 0 ≤ε ≤1. Then 1. 4ε/3 ≤1 + ε (Bernoulli’s inequality), 2. x+εy x+y ≥ε. Next, we show how to approximate deterministically the number of satisfying assignments for a Boolean circuit using a prSBP oracle (i.e. FPprSBP).",
        "metadata": {
            "author": "",
            "keywords": [
                "Implicit",
                "Lemma",
                "SSE",
                "WSSE",
                "prSBP",
                "Bernoulli",
                "prSBP-complete",
                "prAM",
                "Observation",
                "Boolean"
            ]
        }
    },
    {
        "id": "b856e5d5-5bb6-421a-8958-bc178a625520",
        "title": "",
        "chunk_text": "Previously, it was shown that this task could be carried out by a randomized algorithm using an NP oracle (FBPPNP) [Sto85, JVV86] and by a deterministic algorithm using a prAM oracle (FPprAM) 10 [Sip83, GS86]. Lemma 5.6. There exists a deterministic algorithm that given a Boolean circuit C on n variables and a rational number ε > 0 outputs an integer number t satisfying #xC ≤t ≤4ε/3 · #xC ≤(1 + ε)#xC in time polynomial in n, the size of C and 1 ε, given oracle access to SSE. Proof.",
        "metadata": {
            "author": "",
            "keywords": [
                "FBPPNP",
                "algorithm",
                "Previously",
                "FPprAM",
                "oracle",
                "deterministic",
                "shown",
                "task",
                "carried",
                "randomized"
            ]
        }
    },
    {
        "id": "8acaa234-c0ff-4997-8069-b4b10c87970e",
        "title": "",
        "chunk_text": "Let O be a language consistent with SSE. Set k := \u0006 3 ε \u0007 and deﬁne ˆC := C⊗k. Consider the following algorithm: 10Essentially using an oracle access to WSSE. 12 1. If (C, 1) ̸∈O return t = 0 // #xC = 0 2. Find i as the smallest j between 1 and nk + 1 such that \u0010 ˆC, 2j\u0011 ̸∈O 3. return t = \u0004 2i/k\u0005 If #xC = 0 then (C, 1) ̸∈O and the algorithm outputs t = 0. Otherwise, #x ˆC ≥1 and hence \u0010 ˆC, 1 \u0011 ∈O. On the other hand, by deﬁnition #x ˆC ≤2nk and hence \u0010 ˆC, 2nk+1\u0011 ̸∈O.",
        "metadata": {
            "author": "",
            "keywords": [
                "SSE",
                "language",
                "consistent",
                "return",
                "WSSE",
                "algorithm",
                "Set",
                "deﬁne",
                "oracle",
                "access"
            ]
        }
    },
    {
        "id": "31194bae-4c70-459a-bbf1-3636a5a60bd6",
        "title": "",
        "chunk_text": "Therefore, i is well-deﬁned and we have that: • \u0010 ˆC, 2i\u0011 ̸∈O =⇒#x ˆC < 2i =⇒(#xC)k < 2i =⇒#xC < 2i/k =⇒#xC ≤t, • \u0010 ˆC, 2i−1\u0011 ∈O ⇒#x ˆC > 2i−1 2 ⇒(#xC)k > 2i−2 ⇒41/k · #xC > 2i/k ⇒41/k · #xC > t. In conclusion, #xC ≤t ≤41/k · #xC ≤4ε/3 · #xC ≤(1 + ε)#xC. For the running time, the algorithm ﬁnds i by either querying the oracle O at most nk+2 times in parallel or (using binary search) O(log2(nk)) times sequentially, and thus the computation of t can be carried out in time poly(nk).",
        "metadata": {
            "author": "",
            "keywords": [
                "well-deﬁned",
                "time",
                "times",
                "conclusion",
                "search",
                "sequentially",
                "poly",
                "running",
                "algorithm",
                "ﬁnds"
            ]
        }
    },
    {
        "id": "e75feeeb-6fac-49c6-8021-6e9b62952390",
        "title": "",
        "chunk_text": "5.2 Estimating the Average Rank w.r.t. a Linear Order Let U = {0, 1}n. A single-output Boolean circuit E with 2n inputs induces an ordering relation <E on U as x <E y ⇐⇒E(x, y) = 1. If <E is a strict linear order, we call E a linear order circuit. Observation 5.7.",
        "metadata": {
            "author": "",
            "keywords": [
                "Estimating",
                "Rank",
                "Linear",
                "Average",
                "Order",
                "circuit",
                "Boolean",
                "inputs",
                "relation",
                "single-output"
            ]
        }
    },
    {
        "id": "dc4ac50e-0adf-4e20-af76-dd139f3268a4",
        "title": "",
        "chunk_text": "There exists a deterministic Turing machine with SAT oracle that, given a circuit E on 2n variables, stops in time polynomial in n and the size of E and does the following: if E is a linear order circuit, it outputs “yes”; otherwise, it outputs a counterexample: a pair satisfying x <E y <E x or a triple satisfying x <E y <E z <E x. Fix any strict linear order < on U. Deﬁnition 5.8. For an element α ∈U we deﬁne its rank as rank(α) := |{x ∈U | x < α}|.",
        "metadata": {
            "author": "",
            "keywords": [
                "outputs",
                "satisfying",
                "circuit",
                "Turing",
                "SAT",
                "variables",
                "linear",
                "order",
                "stops",
                "counterexample"
            ]
        }
    },
    {
        "id": "19d8616b-bce3-4576-93a0-dd8a84956023",
        "title": "",
        "chunk_text": "We can extend this deﬁnition to non-empty subsets S ⊆U of U by taking the average rank: deﬁne rank(S) := P x∈S rank(x) |S| . If S = {x ∈U | C(x) = 1} is described by a circuit C, we use the same notation: rank(C) = rank(S). Below are some useful observations that we will use later. Observation 5.9. • For a non-empty subset S ⊆U, |{(υ, α) ∈U × S | υ < α}| = |S| · rank(S). • For any α ∈U, rank{υ | υ ≤α} = rank(α)/2. 13 • Let S0, S1 ⊆U be two non-empty disjoint subsets of U.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "non-empty",
                "deﬁne",
                "notation",
                "subsets",
                "extend",
                "deﬁnition",
                "taking",
                "average",
                "circuit"
            ]
        }
    },
    {
        "id": "56335859-99ce-4700-b300-d45aacc8142e",
        "title": "",
        "chunk_text": "Then rank(S0 ∪S1) = |S0| · rank(S0) + |S1| · rank(S1) |S0| + |S1| . In the following lemma the rank is deﬁned w.r.t. the order <E described by a linear order circuit E. This lemma allows us to estimate the rank of a set using a prSBP oracle. Lemma 5.10.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "order",
                "lemma",
                "deﬁned",
                "linear",
                "circuit",
                "oracle",
                "estimate",
                "set",
                "prSBP"
            ]
        }
    },
    {
        "id": "8e7a3f16-f35c-4961-909e-44fd3e1df454",
        "title": "",
        "chunk_text": "There exists a deterministic algorithm that given a Boolean circuit C on n variables, a linear order circuit E on 2n variables, and an ε > 0, outputs a rational number r satisfying: 4−ε · rank(C) ≤r ≤4ε · rank(C) in time polynomial in n, the sizes of C and E, and in 1 ε, given oracle access to SSE. Proof. Consider a circuit D(x, y) := C(y) ∧E(x, y). That is, y is accepted by C and x <E y. By Observation 5.9, #(x,y)D = #xC ·rank(C).",
        "metadata": {
            "author": "",
            "keywords": [
                "variables",
                "SSE",
                "rank",
                "Boolean",
                "circuit",
                "outputs",
                "satisfying",
                "exists",
                "deterministic",
                "algorithm"
            ]
        }
    },
    {
        "id": "c986ed36-f22e-4e39-b193-d1150814e70e",
        "title": "",
        "chunk_text": "By Lemma 5.6 we can compute integers tC and tD that approximate the numbers #xC and #(x,y)D, respectively. Formally, #xC ≤tC ≤4ε · #xC and #(x,y)D ≤tD ≤4ε · #(x,y)D. Therefore we obtain: 4−ε · rank(C) ≤#(x,y)D 4ε · #xC ≤tD tC ≤4ε · #(x,y)D #xC = 4ε · rank(C). 5.3 Finding the Minimum Using a prSBP Oracle We use the approximation algorithms developed above in order to ﬁnd an element that is much closer to the minimum than a given element.",
        "metadata": {
            "author": "",
            "keywords": [
                "Lemma",
                "rank",
                "numbers",
                "compute",
                "integers",
                "approximate",
                "Minimum",
                "element",
                "Formally",
                "Finding"
            ]
        }
    },
    {
        "id": "c2499ed9-78f2-4c40-8196-22e18aa0b655",
        "title": "",
        "chunk_text": "The following lemma describes the procedure Back that given an element α ﬁnds another element β whose rank is smaller by a constant factor. We will use this procedure afterwards in order to ﬁnd the minimum in a polynomial number of iterations. The procedure proceeds by determining the bits of the new element, one coordinate at a time, using a prSBP oracle. The rank is w.r.t. the order <E described by a linear order circuit E. Lemma 5.11.",
        "metadata": {
            "author": "",
            "keywords": [
                "Back",
                "procedure",
                "element",
                "order",
                "factor",
                "describes",
                "smaller",
                "constant",
                "rank",
                "lemma"
            ]
        }
    },
    {
        "id": "32d88267-0bbd-47c5-8cfb-f41ece7a9b11",
        "title": "",
        "chunk_text": "There exists a deterministic algorithm Back that given a linear order circuit E on 2n variables and an element α ∈{0, 1}n, outputs an element β ∈{0, 1}n such that rank(β) ≤ rank(α) √ 2 , in time polynomial in n and the size of E, given oracle access to SSE. Proof. Consider the following procedure: Back(E, α) : 1. Deﬁne C(x) := E(x, α) ∨x = α. // The set of all elements that are <E than or equal to α 2. Set ε = 1/(8n). 3.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "SSE",
                "Back",
                "variables",
                "outputs",
                "exists",
                "deterministic",
                "algorithm",
                "linear",
                "order"
            ]
        }
    },
    {
        "id": "1f8b6ed9-20f6-4a19-8573-7b31dbaf3498",
        "title": "",
        "chunk_text": "For i = 1 to n: (a) For b ∈{0, 1}: deﬁne Cb := C|xi=b 14 (b) For b ∈{0, 1}: if #xCb = 0 then set C := C1−b, βi := 1 −b; continue to the next i // If one of the sets is empty, we choose the other one (c) For b ∈{0, 1}: use Lemma 5.10 to approximate rank(Cb) with ε into rb (d) If r1 ≥r0 then C := C0, βi := 0 else C := C1, βi := 1 // Choose the set with smaller approximate order After each iteration one more variable xi gets its value βi and is substituted into C, that is, in the current circuit C variables x1, .",
        "metadata": {
            "author": "",
            "keywords": [
                "choose",
                "Lemma",
                "set",
                "approximate",
                "xCb",
                "deﬁne",
                "continue",
                "empty",
                "rank",
                "smaller"
            ]
        }
    },
    {
        "id": "73a11f9f-03b8-4c98-8593-0a29c15cab07",
        "title": "",
        "chunk_text": ". . , xi are replaced by the corresponding constants β1, . . . , βi. We claim that after each iteration the rank of the resulting circuit is bounded from the above: rank(C) ≤42εi · rank(α) 2 . Indeed, by Observation 5.9, before the ﬁrst iteration, we have that rank(C) = rank(α) 2 . Now consider any iteration. If C1 or C0 are empty, then rank(C) remains the same and 42εi ≤42ε(i+1). Otherwise, by Lemma 5.10, for b ∈{0, 1} : 4−ε · rank(Cb) ≤rb ≤4ε · rank(Cb).",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "iteration",
                "Observation",
                "Lemma",
                "constants",
                "replaced",
                "empty",
                "remains",
                "claim",
                "resulting"
            ]
        }
    },
    {
        "id": "e1e195c3-a39c-403c-b519-bdb7bcbb78a6",
        "title": "",
        "chunk_text": "If r1 ≥r0 then rank(C1) ≥r1 · 4−ε ≥r0 · 4−ε ≥rank(C0) · 4−2ε and therefore by Observations 5.9 and 5.5(2) rank(C) = #xC0 · rank(C0) + #xC1 · rank(C1) #xC0 + #xC1 ≥#xC0 · rank(C0) + #xC1 · rank(C0) · 4−2ε #xC0 + #xC1 ≥rank(C0) · 4−2ε. Equivalently, rank(C0) ≤rank(C) · 42ε. Similarly, if r1 < r0 then rank(C1) ≤rank(C) · 42ε. Therefore, at each step the rank is multiplied at most by 42ε.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "Observations",
                "Equivalently",
                "Similarly",
                "step",
                "multiplied"
            ]
        }
    },
    {
        "id": "068512a5-6a30-485f-908e-bd50b917c216",
        "title": "",
        "chunk_text": "Consequently, after the n-th iteration, C represents the set that contains only the element β and we have that rank(β) ≤42εn · rank(α)/2 ≤ √ 2 · rank(α)/2 = rank(α)/ √ 2. For the runtime, all the steps can be carried out in time polynomial in n and 1 ε = O(n). Note that the procedure Back has a unique ﬁxed point, namely, the minimal element. Observation 5.12. Back(E, α) = α if and only if α is the minimal element in E. Proof. rank(α) = 0 ⇐⇒rank(α) ≤rank(α)/ √ 2.",
        "metadata": {
            "author": "",
            "keywords": [
                "rank",
                "element",
                "iteration",
                "Back",
                "n-th",
                "represents",
                "set",
                "minimal",
                "runtime",
                "steps"
            ]
        }
    },
    {
        "id": "3dd1a4ae-e32a-444c-8788-301818c606a0",
        "title": "",
        "chunk_text": "We are now ready to prove the main result of this section. Theorem 5.13. LP 2 ⊆PprSBP. Proof. It suﬃces to construct a deterministic polynomial-time algorithm that solves LOP given oracle access to prSBP. Let E be a circuit on 2n inputs. We describe an algorithm for LOP. 1. Check that E is indeed a linear order using Observation 5.7. 15 2. Let α := 0n, β := 1n. 3. While α ̸= β repeat: α := β, β := Back(E, α). 4. Output α. Given Observation 5.7, we can assume w.l.o.g.",
        "metadata": {
            "author": "",
            "keywords": [
                "section",
                "Observation",
                "ready",
                "prove",
                "main",
                "result",
                "LOP",
                "Theorem",
                "algorithm",
                "Back"
            ]
        }
    },
    {
        "id": "29653e62-affa-4b24-bf9e-0e1f14039041",
        "title": "",
        "chunk_text": "that E is a linear order circuit. We claim that the algorithm will output the minimal element after at most 2n iterations. Indeed, by Lemma 5.11, the rank of the element α after 2n iterations satisﬁes rank(α) ≤rank(1n) √ 2 2n ≤2n−1 2n < 1, thus the “While” cycle will be terminated before that. 6 Further Research 1. Can one strengthen our inclusion LP 2 ⊆PprSBP to SP 2 ⊆PprSBP? One can try combining our techniques with the proof of SP 2 ⊆PprAM by Chakaravarthy and Roy [CR11].",
        "metadata": {
            "author": "",
            "keywords": [
                "circuit",
                "iterations",
                "rank",
                "linear",
                "order",
                "element",
                "PprSBP",
                "Lemma",
                "Research",
                "Roy"
            ]
        }
    },
    {
        "id": "ca45bf1c-6cb3-4f03-a57d-cf76e4004ed3",
        "title": "",
        "chunk_text": "Note that in the other direction it is open even whether SBP ⊆SP 2. 2. Chakaravarthy and Roy [CR11] asked whether PprMA and PprSP 2 are contained in SP 2. While we resolved the ﬁrst question, the second one remains open.",
        "metadata": {
            "author": "",
            "keywords": [
                "SBP",
                "Chakaravarthy",
                "Roy",
                "Note",
                "asked",
                "PprSP",
                "open",
                "direction",
                "PprMA",
                "contained"
            ]
        }
    },
    {
        "id": "08b5bd82-ec4e-4669-b315-2f173f09967a",
        "title": "",
        "chunk_text": "We note that, while in the input- oblivious world both inclusions hold (PprOMA ⊆PprOP 2 ⊆OP 2, Theorem 4.4), the proof of the latter inclusion (Lemma 4.3) is essentially input-oblivious (one needs to give all the certiﬁcates for the oracle non-adaptively, and queries cannot be predicted because oracle answers cannot be predicted for promise problems). 3.",
        "metadata": {
            "author": "",
            "keywords": [
                "Theorem",
                "Lemma",
                "predicted",
                "oracle",
                "PprOMA",
                "PprOP",
                "input",
                "oblivious",
                "hold",
                "input-oblivious"
            ]
        }
    },
    {
        "id": "38a125ed-4d95-4c74-8d8f-5c62174905ba",
        "title": "",
        "chunk_text": "While Proposition 4.1 shows a collapse of PH to PprOMA, it does not immediately imply ﬁxed-polynomial size lower bounds for PprOMA, since this class is unlikely to contain NP, so in the case that NP ̸⊆P/poly it may indeed miss hard languages. One can observe that Santhanam’s proof [San09] of Size[nk] lower bounds for promise problems in prMA is input- oblivious. Indeed, the presented hard promise problems are actually in prOMA!",
        "metadata": {
            "author": "",
            "keywords": [
                "Proposition",
                "PprOMA",
                "bounds",
                "size",
                "shows",
                "poly",
                "languages",
                "lower",
                "collapse",
                "immediately"
            ]
        }
    },
    {
        "id": "c6876f79-0703-4e69-b2b5-03845e2805ff",
        "title": "",
        "chunk_text": "However, it does not yield a language in PprOMA that is hard for Size[nk], and we leave this question for further research. 4. Similarly to LP 2, one could deﬁne a class of languages reducible to Avoid. A similar class of search problems, APEPP, has been deﬁned by [KKMP21, Kor21] (and Korten [Kor21] proved that constructing a hard truth table is a problem that is complete for this class under PNP-reductions); however, we are asking about a class of languages.",
        "metadata": {
            "author": "",
            "keywords": [
                "Size",
                "class",
                "research",
                "languages",
                "yield",
                "PprOMA",
                "leave",
                "question",
                "hard",
                "Similarly"
            ]
        }
    },
    {
        "id": "55d85fd4-7853-4f6c-bd0f-7fa8b4e90e73",
        "title": "",
        "chunk_text": "Korten and Pitassi have shown that LP 2 can be equivalently deﬁned using many-one, Turing, or PNP-reductions, thus there are several options. One can observe that the containment PprMA ⊆LP 2 (Theorem 3.4) is essentially proved via the intermediate class PAvoid,NP that uses both an oracle for Range Avoidance (a single-valued or an essentially unique [KP24] version) and an oracle for SAT. Can one prove that one of the containments in PprMA ⊆PAvoid,NP ⊆LP 2 is in fact an equality? 5.",
        "metadata": {
            "author": "",
            "keywords": [
                "Turing",
                "Pitassi",
                "Korten",
                "many-one",
                "PNP-reductions",
                "options",
                "Theorem",
                "oracle",
                "PprMA",
                "shown"
            ]
        }
    },
    {
        "id": "ec18182a-22d7-4b5c-a6f5-20651dfaea36",
        "title": "",
        "chunk_text": "As was mentioned, the FPprSBP procedure for approximate counting can be implemented using parallel (i.e. non-adaptive) oracle queries. On the other hand the containment LP 2 ⊆ PprSBP, which uses approximate counting as a black-box subroutine, seems to require sequen- tial, adaptive queries. Could one implement the latter containment using parallel queries?",
        "metadata": {
            "author": "",
            "keywords": [
                "queries",
                "non-adaptive",
                "approximate",
                "counting",
                "mentioned",
                "oracle",
                "parallel",
                "FPprSBP",
                "procedure",
                "implemented"
            ]
        }
    },
    {
        "id": "1bddb9ae-c140-4aaa-a9b1-674c0e0c911e",
        "title": "",
        "chunk_text": "16 In particular, as PP is consistent with prSBP [BGM06] and is closed under non-adaptive Turing reductions [FR96], this would imply that LP 2 ⊆PP. Note that it is unknown even whether PNP ⊆PP, moreover, there is an oracle separating these two classes [Bei94]. 6. One can deﬁne an input-oblivious version OLP 2 of LP 2 in diﬀerent ways.",
        "metadata": {
            "author": "",
            "keywords": [
                "Turing",
                "prSBP",
                "reductions",
                "consistent",
                "closed",
                "non-adaptive",
                "imply",
                "PNP",
                "OLP",
                "Note"
            ]
        }
    },
    {
        "id": "12f13f0d-ad8e-4fe9-8d4b-9d53fc4226f4",
        "title": "",
        "chunk_text": "One of the ways will provide a class that contains hard functions similarly to SP 2 [Li23], OP 2 [GLV24], and LP 2 [KP24], and one can extend the proof of PprMA ⊆LP 2 to show PprOMA ⊆POLP 2 . We have not veriﬁed it so far and leave it as another conjecture for the moment. If true, it will also prove the Karp–Lipton–style theorem for OLP 2, which does not follow from known results otherwise.",
        "metadata": {
            "author": "",
            "keywords": [
                "POLP",
                "PprMA",
                "PprOMA",
                "moment",
                "provide",
                "class",
                "hard",
                "functions",
                "similarly",
                "extend"
            ]
        }
    },
    {
        "id": "ce6cfbea-1ebc-42fa-9386-8bee2af730d1",
        "title": "",
        "chunk_text": "Acknowledgement The authors are grateful to Yaroslav Alekseev for discussing and to Dmitry Itsykson for discussing and proofreading a preliminary version of this paper. References [AGHK11] B. Aydinlio˜glu, D. Gutfreund, J. M. Hitchcock, and A. Kawachi. Derandomizing arthur- merlin games and approximate counting implies exponential-size lower bounds. Com- put. Complex., 20(2):329–366, 2011. [AKSS95] V. Arvind, J. K¨obler, U. Sch¨oning, and R. Schuler.",
        "metadata": {
            "author": "",
            "keywords": [
                "discussing",
                "Yaroslav",
                "Alekseev",
                "Dmitry",
                "Itsykson",
                "Acknowledgement",
                "paper",
                "authors",
                "grateful",
                "proofreading"
            ]
        }
    },
    {
        "id": "17cd4d5c-bfda-4d23-a1dc-f193f3942ba9",
        "title": "",
        "chunk_text": "If NP has polynomial-size circuits, then MA=AM. Theor. Comput. Sci., 137(2):279–282, 1995. [BCG+96] N. H. Bshouty, R. Cleve, R. Gavald`a, S. Kannan, and C. Tamon. Oracles and queries that are suﬃcient for exact learning. J. Comput. Syst. Sci., 52(3):421–433, 1996. [Bei94] R. Beigel. Perceptrons, PP, and the polynomial hierarchy. Computational Complexity, 4:339–349, 1994. [BF99] H. Buhrman and L. Fortnow. One-sided versus two-sided error in probabilistic compu- tation.",
        "metadata": {
            "author": "",
            "keywords": [
                "circuits",
                "Sci.",
                "Comput",
                "polynomial-size",
                "BCG",
                "Theor",
                "Bshouty",
                "Cleve",
                "Gavald",
                "Kannan"
            ]
        }
    },
    {
        "id": "917531a4-6485-473d-acec-63820c941afd",
        "title": "",
        "chunk_text": "In STACS, pages 100–109, 1999. [BFT98] H. Buhrman, L. Fortnow, and T. Thierauf. Nonrelativizing separations. In Proceedings of the 13th Annual IEEE Conference on Computational Complexity (CCC), pages 8–12, 1998. [BGM06] E. B¨ohler, C. Glaßer, and D. Meister. Error-bounded probabilistic computations be- tween MA and AM. J. Comput. Syst. Sci., 72(6):1043–1076, 2006. [Cai07] J.-Y. Cai. S2P ⊆ZPP NP . Journal of Computer and System Sciences, 73(1):25–35, 2007. [Can96] R. Canetti.",
        "metadata": {
            "author": "",
            "keywords": [
                "STACS",
                "pages",
                "Fortnow",
                "Thierauf",
                "CCC",
                "Annual",
                "Complexity",
                "Buhrman",
                "Glaßer",
                "Meister"
            ]
        }
    },
    {
        "id": "3e4b3677-5d17-4b9c-89ec-cd31647485e6",
        "title": "",
        "chunk_text": "More on BPP and the polynomial-time hierarchy. Inf. Process. Lett., 57(5):237–241, 1996. 17 [CHR24] L. Chen, S. Hirahara, and H. Ren. Symmetric exponential time requires near-maximum circuit size. In Proceedings of the 56th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2024, to appear. Association for Computing Machinery, 2024. [CR06] V. T. Chakaravarthy and S. Roy. Oblivious symmetric alternation. In STACS, pages 230–241, 2006. [CR11] V. T. Chakaravarthy and S. Roy.",
        "metadata": {
            "author": "",
            "keywords": [
                "BPP",
                "hierarchy",
                "Roy",
                "Chakaravarthy",
                "polynomial-time",
                "Computing",
                "STOC",
                "Symmetric",
                "Hirahara",
                "Ren"
            ]
        }
    },
    {
        "id": "d81fdaa9-1a60-4e72-8409-df7157cd860c",
        "title": "",
        "chunk_text": "Arthur and Merlin as oracles. Comput. Complex., 20(3):505–558, 2011. [FR96] L. Fortnow and N. Reingold. PP is closed under truth-table reductions. Inf. Comput., 124(1):1–6, 1996. [GLV24] K. Gajulapalli, Z. Li, and I. Volkovich. Oblivious classes revisited: Lower bounds and hierarchies. Electron. Colloquium Comput. Complex., TR24-049, 2024. [GM15] O. Goldreich and O. Meir. Input-oblivious proof systems and a uniform complexity perspective on P/poly.",
        "metadata": {
            "author": "",
            "keywords": [
                "Merlin",
                "Arthur",
                "oracles",
                "Complex.",
                "Comput",
                "Reingold",
                "Volkovich",
                "Lower",
                "Meir",
                "Comput."
            ]
        }
    },
    {
        "id": "e41198ea-e3fa-405a-af71-7a02fcb2ab92",
        "title": "",
        "chunk_text": "ACM Transactions on Computation Theory (TOCT), 7(4):1– 13, 2015. [GS86] S. Goldwasser and M. Sipser. Private coins versus public coins in interactive proof systems. In Proceedings of the 18th Annual ACM Symposium on Theory of Computing (STOC), pages 59–68, 1986. [GS88] J. Grollmann and A. L. Selman. Complexity measures for public-key cryptosystems. SIAM J. Comput., 17(2):309–335, 1988. [HS15] E. A. Hirsch and D. Sokolov. On the probabilistic closure of the loose unambiguous hierarchy. Inf.",
        "metadata": {
            "author": "",
            "keywords": [
                "TOCT",
                "Transactions",
                "Computation",
                "ACM",
                "Theory",
                "STOC",
                "Sipser",
                "coins",
                "Annual",
                "Computing"
            ]
        }
    },
    {
        "id": "fad6cf4e-35f7-497b-a0a9-d6bbf2dca401",
        "title": "",
        "chunk_text": "Process. Lett., 115(9):725–730, 2015. [IKV23] R. Impagliazzo, V. Kabanets, and I. Volkovich. Synergy between circuit obfuscation and circuit minimization. In Nicole Megow and Adam D. Smith, editors, Approxi- mation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, APPROX/RANDOM 2023, September 11-13, 2023, Atlanta, Georgia, USA, volume 275 of LIPIcs, pages 31:1–31:21. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2023. [JVV86] M. Jerrum, L. G. Valiant, and V. V.",
        "metadata": {
            "author": "",
            "keywords": [
                "Process",
                "circuit",
                "Lett.",
                "Kabanets",
                "Volkovich",
                "Approxi",
                "Randomization",
                "APPROX",
                "RANDOM",
                "Atlanta"
            ]
        }
    },
    {
        "id": "c0e86fa9-f5cb-451c-83f9-de90e3e4fdb0",
        "title": "",
        "chunk_text": "Vazirani. Random generation of combinatorial structures from a uniform distribution. Theor. Comput. Sci., 43:169–188, 1986. [Kan82] R. Kannan. Circuit-size lower bounds and non-reducibility to sparse sets. Information and Control, 55(1-3):40–56, 1982. [KKMP21] R. Kleinberg, O. Korten, D. Mitropolsky, and C. Papadimitriou. Total Functions in the Polynomial Hierarchy. In James R.",
        "metadata": {
            "author": "",
            "keywords": [
                "Vazirani",
                "Theor",
                "Random",
                "distribution",
                "Comput",
                "Sci.",
                "43:169",
                "Control",
                "Korten",
                "Mitropolsky"
            ]
        }
    },
    {
        "id": "c8ddec66-e3fa-44f8-9267-980f5b33387d",
        "title": "",
        "chunk_text": "Lee, editor, 12th Innovations in Theoretical Computer Science Conference (ITCS 2021), volume 185 of Leibniz International Pro- ceedings in Informatics (LIPIcs), pages 44:1–44:18, Dagstuhl, Germany, 2021. Schloss Dagstuhl–Leibniz-Zentrum f¨ur Informatik. 18 [KL80] R. M. Karp and R. J. Lipton. Some connections between nonuniform and uniform complexity classes.",
        "metadata": {
            "author": "",
            "keywords": [
                "ITCS",
                "Germany",
                "Innovations",
                "Conference",
                "Pro",
                "Informatics",
                "Dagstuhl",
                "Lee",
                "editor",
                "volume"
            ]
        }
    },
    {
        "id": "0cb96fba-9ba0-4a5b-983e-3c0086aeedac",
        "title": "",
        "chunk_text": "In Proceedings of the 12th Annual ACM Symposium on Theory of Computing, April 28-30, 1980, Los Angeles, California, USA, pages 302–309, 1980. [Kor21] O. Korten. The hardest explicit construction. CoRR, abs/2106.00875, 2021. [KP24] O. Korten and T. Pitassi. Strong vs. Weak Range Avoidance and the Linear Ordering Principle. Electron. Colloquium Comput. Complex., TR24-076, 2024. Extended abstract published in FOCS-2024. [KW98] J. K¨obler and O. Watanabe.",
        "metadata": {
            "author": "",
            "keywords": [
                "California",
                "USA",
                "Annual",
                "Computing",
                "April",
                "Los",
                "Angeles",
                "Proceedings",
                "ACM",
                "Symposium"
            ]
        }
    },
    {
        "id": "91ece800-44b9-4eb5-a0dc-df3c9af24be0",
        "title": "",
        "chunk_text": "New collapse consequences of NP having small circuits. SIAM J. Comput., 28(1):311–324, 1998. [Li23] X. Li. Two source extractors for asymptotically optimal entropy, and (many) more. In 2023 IEEE 64th Annual Symposium on Foundations of Computer Science (FOCS), pages 1271–1281, Los Alamitos, CA, USA, nov 2023. IEEE Computer Society. [Li24] Z. Li. Symmetric exponential time requires near-maximum circuit size: Simpliﬁed, truly uniform.",
        "metadata": {
            "author": "",
            "keywords": [
                "IEEE",
                "SIAM",
                "Computer",
                "FOCS",
                "USA",
                "collapse",
                "consequences",
                "small",
                "Simpliﬁed",
                "Comput."
            ]
        }
    },
    {
        "id": "d9ca69a2-5c37-429e-9f70-3e03fa8fad3b",
        "title": "",
        "chunk_text": "In Proceedings of the 56th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2024, to appear. Association for Computing Machinery, 2024. [LR94] K.-J. Lange and P. Rossmanith. Unambiguous polynomial hierarchies and exponential size. In Structure in Complexity Theory Conference, pages 106–115. IEEE Computer Society, 1994. [MVW99] P. B. Miltersen, N. V. Vinodchandran, and O. Watanabe. Super-polynomial versus half-exponential circuit size in the exponential hierarchy.",
        "metadata": {
            "author": "",
            "keywords": [
                "STOC",
                "Annual",
                "Proceedings",
                "ACM",
                "SIGACT",
                "Symposium",
                "Computing",
                "Theory",
                "Machinery",
                "Rossmanith"
            ]
        }
    },
    {
        "id": "667d86f8-3ed3-4703-9467-9d203ee0f7db",
        "title": "",
        "chunk_text": "In COCOON, pages 210–220, 1999. [RS98] A. Russell and R. Sundaram. Symmetric alternation captures BPP. Comput. Complex., 7(2):152–162, 1998. [San09] R. Santhanam. Circuit lower bounds for Merlin–Arthur classes. SIAM J. Comput., 39(3):1038–1061, 2009. [Sch83] U. Sch¨oning. A low and a high hierarchy within NP. Journal of Computer and System Sciences, 27:14–28, 1983. [Sip83] M. Sipser. A complexity theoretic approach to randomness.",
        "metadata": {
            "author": "",
            "keywords": [
                "COCOON",
                "pages",
                "Sundaram",
                "BPP",
                "Merlin",
                "Arthur",
                "SIAM",
                "Comput",
                "Russell",
                "Sciences"
            ]
        }
    },
    {
        "id": "6bf131b9-b4bf-476e-b69a-ccc8bc12705c",
        "title": "",
        "chunk_text": "In Proceedings of the 15th Annual ACM Symposium on Theory of Computing, 25-27 April, 1983, Boston, Massachusetts, USA, pages 330–335. ACM, 1983. [Sto85] L. J. Stockmeyer. On approximation algorithms for #P. SIAM J. Comput., 14(4):849– 861, 1985. [SU06] R. Shaltiel and C. Umans. Pseudorandomness for approximate counting and sampling. Comput. Complex., 15(4):298–341, 2006. [Tod91] S. Toda. PP is as hard as the polynomial time hierarchy. SIAM J. on Computing, 20(5):865–877, 1991. 19 [Vin05] N. V.",
        "metadata": {
            "author": "",
            "keywords": [
                "Boston",
                "Massachusetts",
                "USA",
                "Annual",
                "April",
                "Proceedings",
                "Symposium",
                "Theory",
                "ACM",
                "pages"
            ]
        }
    },
    {
        "id": "1382d384-5304-4d30-a989-014422778458",
        "title": "",
        "chunk_text": "Vinodchandran. A note on the circuit complexity of PP. Theor. Comput. Sci., 347(1-2):415–418, 2005. [Vol14] I. Volkovich. On learning, lower bounds and (un)keeping promises. In Proceedings of the 41st ICALP, pages 1027–1038, 2014. [Vol20] I. Volkovich. The untold story of SBP. In Henning Fernau, editor, The 15th Interna- tional Computer Science Symposium in Russia, CSR, volume 12159 of Lecture Notes in Computer Science, pages 393–405. Springer, 2020.",
        "metadata": {
            "author": "",
            "keywords": [
                "Vinodchandran",
                "Volkovich",
                "pages",
                "Computer",
                "Science",
                "ICALP",
                "Interna",
                "CSR",
                "Theor",
                "SBP"
            ]
        }
    },
    {
        "id": "de82e0cf-0d81-48c3-a7d0-8723291a1a85",
        "title": "",
        "chunk_text": "A A Karp–Lipton–style Collapse to PprOMA The following proposition shows that the collapse of [CR11] can be actually pushed down to PprOMA. For this, we observe that by standard techniques (e.g. [AKSS95]) prAM ⊆prOMA under NP ⊆P/poly. Proposition A.1. If NP ⊆P/poly, then prAM ⊆prOMA and PH = PprOMA. Proof. If NP ⊆P/poly, then Merlin’s proof in prMA can be made input-oblivious. Let us show it ﬁrst for a larger class: prAM.",
        "metadata": {
            "author": "",
            "keywords": [
                "Lipton",
                "Collapse",
                "Karp",
                "poly",
                "prAM",
                "PprOMA",
                "style",
                "prOMA",
                "proposition",
                "pushed"
            ]
        }
    },
    {
        "id": "3aa7fdfd-6489-43c3-887a-6de57372957f",
        "title": "",
        "chunk_text": "If (ΠYES, ΠNO) ∈prAM, then there is a polynomial-time Turing machine A such that ∀x ∈ΠYES ∀r ∃w A(x, r, w) = 1, ∀x ∈ΠNO Pr r [∃w A(x, r, w) = 1] < 1/2. Let us ask Merlin to send a family Sn of CircuitSAT circuits of appropriate input sizes (slightly abusing the notation: Sn contains circuits for a polynomial range of input sizes, not just n); one can assume that they compute a correct satisfying assignment or say “no” (they can lie only if they say “no” for a satisﬁable formula).",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "Turing",
                "prAM",
                "sizes",
                "polynomial-time",
                "machine",
                "input",
                "circuits",
                "Merlin"
            ]
        }
    },
    {
        "id": "2299c841-82e2-446b-898c-8783042a95ed",
        "title": "",
        "chunk_text": "Consider the Boolean circuit Ax,r obtained by embedding x and r into A, its variables are the bits of the witness w. Now Arthur can use this circuit instead of Merlin’s original proof: ∀n ∈N ∃Sn ∀x ∈ΠYES ∀r A(x, r, Sn(Ax,r)) = 1, ∀x ∈ΠNO Pr r [∃Sn A(x, r, Sn(Ax,r)) = 1] < 1/2. The ﬁrst condition is true because Merlin can send correct CircuitSAT circuits. The second condition is true because if such a Sn existed, then the original Merlin could have sent w = Sn(Ax,r).",
        "metadata": {
            "author": "",
            "keywords": [
                "Ax,r",
                "Boolean",
                "Merlin",
                "ΠYES",
                "ΠNO",
                "circuit",
                "obtained",
                "embedding",
                "variables",
                "bits"
            ]
        }
    },
    {
        "id": "2ad4da12-41ce-4a95-9c64-fc31310c1351",
        "title": "",
        "chunk_text": "Note that in this case although Sn may depend on x and r, A will able to catch a cheating Merlin. If we relax it by pulling the existential quantiﬁer over Sn outside, we get exactly the deﬁnition of prOMA: ∀n ∈N ∃Sn ∀x ∈ΠYES ∀r A(x, r, Sn(Ax,r)) = 1, ∀x ∈ΠNO ∀Sn Pr r [A(x, r, Sn(Ax,r)) = 1] < 1/2. Therefore, if NP ⊆P/poly, then prAM ⊆prOMA. In [CR11], it is shown that under the same premises PH = PprAM and hence the claim follows by combining these results.",
        "metadata": {
            "author": "",
            "keywords": [
                "Ax,r",
                "Merlin",
                "Note",
                "prOMA",
                "ΠYES",
                "ΠNO",
                "case",
                "depend",
                "catch",
                "cheating"
            ]
        }
    },
    {
        "id": "5e85c950-7bf3-4170-a4af-62a0373f889b",
        "title": "",
        "chunk_text": "20 B Promise Oblivious Merlin–Arthur Protocols are in Promise OP 2 The following proof essentially repeats the proof of [CR06, Theorem 3], which says that MA ⊆ NOP 2, we need to verify that it holds for promise problems as well, and Merlin’s advice remains oblivious if it was oblivious before, that is, prOMA ⊆prOP 2. Proposition B.1. prOMA ⊆prOP 2. Proof. Consider a promise problem Π = ΠY ˙∪ΠN ∈prOMA.",
        "metadata": {
            "author": "",
            "keywords": [
                "Merlin",
                "Theorem",
                "NOP",
                "Oblivious",
                "prOMA",
                "Arthur",
                "Protocols",
                "prOP",
                "Promise",
                "proof"
            ]
        }
    },
    {
        "id": "d863cd8b-cd09-41f3-9259-0a4d26e0b3f1",
        "title": "",
        "chunk_text": "There is a polynomial-time deterministic machine A such that ∀n ∈N ∃wn ∀x ∈ΠYES ∀r A(x, r, wn)) = 1, (1) ∀x ∈ΠNO ∀w Pr r [A(x, r, w) = 1] < 1/2.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "polynomial-time",
                "deterministic",
                "machine"
            ]
        }
    },
    {
        "id": "de2b5991-3e15-4258-a843-24d8dd7bc3e7",
        "title": "",
        "chunk_text": "(2) Condition (2) can be replaced by ∀n ∈N ∃r′ n ∀x ∈ΠN ∩{0, 1}n ∀w ∈{0, 1}p(n) A(x, w, r′ n) = 0 (2’) because of the Adleman’s trick (similarly to the treatment of RP ⊆ONP in [GM15] or MA ⊆ NOP 2 in [CR06]): given x and w, the new veriﬁer can apply the old one as A(x, w, ri) for np(n) independent random strings ri ∈{0, 1}t(n) in order to reduce the error from 1 2 to 1 2 · 1 2np(n) .",
        "metadata": {
            "author": "",
            "keywords": [
                "Condition",
                "NOP",
                "ONP",
                "Adleman",
                "trick",
                "similarly",
                "independent",
                "replaced",
                "treatment",
                "veriﬁer"
            ]
        }
    },
    {
        "id": "8489e656-8e2f-4e3d-9b5f-3533f63cc2aa",
        "title": "",
        "chunk_text": "Since for every pair (x, w) there are at most a 1 2 · 1 2np(n) fraction of strings r′ n ∈{0, 1}tnp(n) results in an error, there exists r′ that satisﬁes (2’). It does not harm the condition (1) as well. Therefore, Merlin’s proof w remains input-oblivious, whereas Arthur’s universal random string r′ n is input-oblivious and w-oblivious. C Loose Oracle Access vs Access Through a Consistent Language One must be very careful when arguing about oracle access to promise classes.",
        "metadata": {
            "author": "",
            "keywords": [
                "tnp",
                "Access",
                "pair",
                "fraction",
                "results",
                "error",
                "satisﬁes",
                "exists",
                "Oracle",
                "Merlin"
            ]
        }
    },
    {
        "id": "a24f55ea-f9b3-45df-9cfd-972ed646d802",
        "title": "",
        "chunk_text": "Several modes of access have been considered in the literature including guarded access [LR94], loose access (e.g., [CR11, HS15]), and access through a consistent language [GS88, BF99]. In this paper we use the same mode of access as in [CR11]. Fortunately, when the underlying computational model is a polynomial-time Turing machine [with a speciﬁc polynomial-time alarm clock], loose access is equivalent to access through a consistent language.",
        "metadata": {
            "author": "",
            "keywords": [
                "access",
                "loose",
                "language",
                "consistent",
                "considered",
                "literature",
                "including",
                "guarded",
                "modes",
                "mode"
            ]
        }
    },
    {
        "id": "e96cb770-0337-4cb6-bf3f-dbc9068f7fbf",
        "title": "",
        "chunk_text": "In order to make this connection very clear, below we deﬁne both of them rigorously and show the equivalence. Note that for other computational devices, such as those corresponding to OP 2 • or SP 2 •, the connection between the modes is much less clear. Access through a consistent language. The following deﬁnition is from [GS88]. Deﬁnition C.1 (promise problem, consistency). Consider a promise problem Π = (ΠYES, ΠNO), where ΠYES ∩ΠNO = ∅.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠNO",
                "clear",
                "equivalence",
                "ΠYES",
                "connection",
                "order",
                "make",
                "deﬁne",
                "rigorously",
                "show"
            ]
        }
    },
    {
        "id": "c926e21b-1520-48bd-9ab8-fa6aadaf402a",
        "title": "",
        "chunk_text": "We say that a language O is consistent with Π if ΠYES ⊆O and ΠNO ⊆O. The containment of O outside of ΠYES ∪ΠNO can be arbitrary. Let us denote it O ⊂ ∼Π. In one line of the literature [GS88, BF99], when an oracle is described as a promise problem, the following mode of access is used (access through a consistent language): the outer Turing machine queries a language L consistent with this promise problem. In particular, it is allowed to make 21 queries outside of the promise set.",
        "metadata": {
            "author": "",
            "keywords": [
                "ΠYES",
                "ΠNO",
                "language",
                "consistent",
                "promise",
                "problem",
                "queries",
                "access",
                "Turing",
                "arbitrary"
            ]
        }
    },
    {
        "id": "61169e72-3d68-4ae3-a9bc-9cfc97bdbe88",
        "title": "",
        "chunk_text": "However, the outer Turing machine must return a correct answer for every possible choice of L. Let us formalize it in the simplest case of PΠ: Deﬁnition C.2. A language L ∈PΠ according to the consistent language mode if there is a deterministic oracle Turing machine M• with polynomial-time alarm clock stopping it in time p(n) such that for every O ⊂ ∼Π and for every input x, MO(x) = L(x).",
        "metadata": {
            "author": "",
            "keywords": [
                "Turing",
                "Deﬁnition",
                "machine",
                "outer",
                "return",
                "correct",
                "answer",
                "choice",
                "language",
                "formalize"
            ]
        }
    },
    {
        "id": "1ed449bf-f16b-4642-8737-76e0ffdb8446",
        "title": "",
        "chunk_text": "One can observe that for every such language O, PΠ ⊆PO, therefore the following holds as well, and in fact can be considered as an alternative deﬁnition. Deﬁnition C.3 (promise problems as oracles). PΠ := T ΠYES⊆O ΠNO⊆O PO. For more details and discussion see e.g. [GS88, BF99]. Loose access. In the loose access mode, one considers oracle as a black box (physical device) that is only guaranteed to work correctly on the promise set.",
        "metadata": {
            "author": "",
            "keywords": [
                "deﬁnition",
                "observe",
                "language",
                "holds",
                "fact",
                "considered",
                "alternative",
                "ΠYES",
                "ΠNO",
                "Loose"
            ]
        }
    },
    {
        "id": "87029992-f735-4e2f-8591-012adc6d081f",
        "title": "",
        "chunk_text": "Outside this set it can produce any answer, in particular, it can give diﬀerent answers to the same query, either during one deterministic computation, or for diﬀerent witnesses if the computational model uses them, or for diﬀerent inputs. Let us deﬁne it rigorously in the simplest case of PΠ: Deﬁnition C.4.",
        "metadata": {
            "author": "",
            "keywords": [
                "diﬀerent",
                "query",
                "computation",
                "inputs",
                "Deﬁnition",
                "set",
                "produce",
                "give",
                "deterministic",
                "witnesses"
            ]
        }
    },
    {
        "id": "9f6a02bd-4550-42ec-81eb-93a36bea11aa",
        "title": "",
        "chunk_text": "A language L ∈PΠ according to the loose access mode if there is a deterministic oracle Turing machine M• with polynomial-time alarm clock stopping it in time p(n) such that for every input x M•(x) produces the answer L(x) if the oracle answers “yes” on queries in ΠY and answers “no” on queries in ΠN. (No hypothesis is made on its behaviour outside ΠY ∪ΠN, in particular, its answers may be inconsistent for the same query.) Equivalence for PΠ.",
        "metadata": {
            "author": "",
            "keywords": [
                "queries",
                "Turing",
                "oracle",
                "answers",
                "produces",
                "language",
                "loose",
                "access",
                "mode",
                "deterministic"
            ]
        }
    },
    {
        "id": "b4d613c1-0705-4b7e-93bb-faab1b9a4d2c",
        "title": "",
        "chunk_text": "Fortunately, it is very easy to verify the equivalence of these two deﬁnitions in the case of PΠ. Proposition C.5. Let Π be a promise problem. A language L belongs to PΠ according to the loose access mode if and only if it belongs to PΠ according to access through a consistent language. Proof. The “only if” direction is trivial since a consistent language is a particular case of a black box. For the “if” direction, consider M• from the deﬁnition of access through a consistent language.",
        "metadata": {
            "author": "",
            "keywords": [
                "language",
                "consistent",
                "Fortunately",
                "access",
                "easy",
                "verify",
                "equivalence",
                "case",
                "direction",
                "belongs"
            ]
        }
    },
    {
        "id": "9e8101ae-5b3c-4145-8490-63e5bca9328f",
        "title": "",
        "chunk_text": "To make it tolerant to the loose access mode, maintain a table of oracle answers, and if M• attempts to repeat the same query, use the answer from the table instead. The deﬁnition of the machine will not change if its oracle is a language, thus it will still produce the same answer.",
        "metadata": {
            "author": "",
            "keywords": [
                "table",
                "mode",
                "maintain",
                "attempts",
                "query",
                "oracle",
                "answer",
                "make",
                "tolerant",
                "loose"
            ]
        }
    },
    {
        "id": "9e8e1c5c-3770-41e5-8f8e-8e1be682acda",
        "title": "",
        "chunk_text": "On the other hand, its behaviour on input x when given a blackbox oracle is the same as its behaviour when given the following language Lx as an oracle: Lx = ΠY ∪Yx, where Yx is the set of all queries for which the blackbox oracle gave the answer “yes” when asked for the ﬁrst time. Since Lx is consistent with Π, MLx(x) = L(x) according to the deﬁnition of access through a consistent language. 22",
        "metadata": {
            "author": "",
            "keywords": [
                "oracle",
                "behaviour",
                "blackbox",
                "language",
                "hand",
                "answer",
                "time",
                "input",
                "set",
                "queries"
            ]
        }
    }
]